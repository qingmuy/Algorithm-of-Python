# 题目以及解析

LeetCode：100x

洛谷：200x

卡码：300x

 

## 目录

### 数据结构

#### 字符串

[1003 - 罗马数字转整数](#p1003)

[1004 - 最长公共前缀](#p1004)

[1005 - 有效的括号](#p1005)

[1009 - 找出字符串中第一个匹配项的下标](#p1009)

[1011 - 最后一个单词的长度](#p1011)

[1013 - 二进制求和](#p1013)

[1029 - 验证回文串](#p1029)

[1036 - 反转字符串](#p1036)

[1037 - 反转字符串 II](<a id="p1037"></a>)

[1039 - 密钥格式化](#p1039)

[1049 - 有效的字母异位](#p1049)

[1053 - 赎金信](#p1053)

[1056 - 反转字符串中的单词](#p1056)

[1057 - 重复的子字符串](#p1057)

[3001 - 替换数字](#p3001)

[3002 -  右旋字符串](#p3002)

[1058 - 删除字符串中的所有相邻重复项](#p1058)



#### 链表

[1006 - 合并两个有序链表](#p1006)

[1016 - 删除排序链表中的重复元素](#p1016)

[1031 - 环形链表](#p1031)

[1043 - 设计链表](#p1043)

[1044 - 反转链表](#p1044)

[1046 - 删除链表的倒数第N个结点](#p1046)

[1047 - 链表相交](#p1047)

[1034 - 两数相加](#p1034)



#### 栈

[1005 - 有效的括号](#p1005)

[1018：二叉树的中序遍历](#p1018)

[1058 - 删除字符串中的所有相邻重复项](#p1058)

[1059 - 逆波兰表达式求值](#p1059)



#### 队列

[1060 - 滑动窗口的最大值](#p1060)



#### 树

[1018 - 二叉树的中序遍历](#p1018)

[1019 - 相同的树](#p1019)

[1020 - 对称二叉树](#p1020)

[1021 - 二叉树的最大深度](#p1021)

[1022 - 将有序数组转换为二叉搜索树](#p1022)

[1023 - 平衡二叉树](#p1023)

[1024 - 二叉树的最小深度](#p1024)

[1025 - 路径总和](#p1025)

[1032 - 二叉树的前序遍历](#p1032)

[1033 - 二叉树的后序遍历](#p1033)

[1062 - 二叉树的层序遍历](#p1062)

[1063 - 二叉树的右视图](#p1063)

[1064 - 二叉树的层平均值](#p1064)

[1065 - N叉树的层序遍历](#p1065)

[1066 - 在每个树行中找最大值](#p1066)

[1067 - 填充每个节点的下一个右侧节点指针](#p1067)

[1068 - 填充每个节点的下一个右侧节点指针 II](#p1068)

[1069 - 翻转二叉树](#p1069)

[1070 - 完全二叉树的节点个数](#p1070)

[1071 - 二叉树的所有路径](#p1071)

[1072 - 左叶子之和](#p1072)

[1073 - 找树左下角的值](#p1073)

[1074 - 路径总和 II](#p1074)

[1075 - 从中序与后序遍历序列构造二叉树](#p1075)

[1076 - 最大二叉树](#p1076)

[1077 - 合并二叉树](#p1077)

[1078 - 二叉搜索树中的搜索](#p1078)

[1079 - 验证二叉搜索树](#p1079)

[1080 - 二叉搜索树的最小绝对差](#p1080)

[1081 - 二叉搜索树中的众数](#p1081)

[1082 - 二叉树的最近公共祖先](#p1082)

[1083 - 二叉搜索树的最近公共祖先](#p1083)

[1084 - 二叉搜索树中的插入操作](#p1084)

[1085 - 删除二叉搜索树中的节点](#p1085)

[1086 - 修建二叉搜索树](#p1086)

[1087 - 把二叉搜索树转换为累加树](#p1087)

[1088 - 二叉搜索树中的插入操作](#p1088)

[1101 - 二叉树的层序遍历 II](#p1101)

[1147 - 所有可能的真二叉树](#p1147)



#### 哈希表

[1001 - 两数之和](#p1001)

[1003 - 罗马数字转整数](#p1003)

[1049 - 有效的字母异位](#p1049)

[1050 - 两个数组的交集](#p1050)

[1051 - 快乐数](#p1051)

[1052 - 四数相加 II](#p1052)

[1053 - 赎金信](#p1053)

[1061 - 前k个高频元素](#p1061)



### 解题方法

#### 双指针

[1007 - 删除有序数组中的重复项](#p1007)

[1008 - 移除元素](#p1008)

[1009 - 找出字符串中第一个匹配项的下标](#p1009)

[1017 - 合并两个有序数组](#p1017)

[1029 - 验证回文串](#p1029)

[1031 - 环形链表](#p1031)

[1036 - 反转字符串](#p1036)

[1038 - 有序数组的平方](#p1038)

[1046 - 删除链表的倒数第N个结点](#p1046)

[1047 - 链表相交](#p1047)

[1054 - 三数之和](#p1054)

[1055 - 四数之和](#p1055)

[1056 - 反转字符串中的单词](#p1056)



#### 回溯

[1071 - 二叉树的所有路径](#p1071)

[1089 - 组合](#p1089)

[1090 - 组合总和 III](#p1090)

[1091 - 电话号码的字母组合](#p1091)

[1092 - 组合总和](#p1092)

[1093 - 组合总和 II](#p1093)

[1095 - 复原 IP 地址](#p1095)

[1096 - 子集](#p1096)

[1097 - 子集 II](#p1097)

[1098 - 非递减子序列](#p1098)

[1099 - 全排列](#p1099)

[1100 - 全排列 II](#p1100)



#### 贪心

[1105 - 分发饼干](#p1105)

[1106 - 摆动序列](#p1106)

[1028 - 买卖股票的最佳时机](#p1128)

[1108 - 买卖股票的最佳时机 II](#p1108)

[1110 - 跳跃游戏 II](#p)

[1111 - K次取反后最大化的数组和](#p1111)

[1112 - 加油站](#p1112)

[1113 - 柠檬水找零](#p1113)

[1114 - 发发糖果](#p1114)

[1115 - 根据身高重建队列](#p1115)

[1116 - 用最少数量的箭引爆气球](#p1116)

[1117 - 无重叠区间](#p1117)

[1118 - 划分字母区间](#p1118)

[1119 - 合并区间](#p1119)

[1120 - 单调递增的数字](#p1120)

[1121 - 监控二叉树](#p1121)



#### 动态规划

[1015 - 爬楼梯](#p1015)

[1026 - 杨辉三角](#p1015)

[1027 - 杨辉三角 II](#p1027)

[1028 - 买卖股票的最佳时机](#p1028)

[1122 - 斐波那契数列](#p1122)

[1123 - 使用最小花费爬楼梯](#p1123)

[1124 - 不同路径](#p1124)

[1125 - 不同路径 II](#p1125)

[1126 - 整数拆分](#p1126)

[1127 - 不同的二叉搜索树](#p1127)

[3003 - 背包问题](#p3003)

[1128 - 分割等和子集](#p1128)

[1129 - 最后一块石头的重量 II](#p1129)

[1131 - 一和零](#p1131)

[3004 - 完全背包问题](#p3004)

[1132 - 零钱兑换 II](#p1132)

[1133 - 组合总数 IV](#p1)

[3005 - 爬楼梯 II](#p3005)

[1134 - 零钱兑换](#p1134)

[1135 - 单词拆分](#p1135)

[1136 - 打家劫舍](#p1136)

[1137 - 打家劫舍 II](#p1137)

[1138 - 打家劫舍 III](#p1138)

[1139 - 买卖股票的最佳时机 III](#p1139)

[1140 - 买卖股票的最佳时机 IV](#p1140)

[1141 - 买卖股票的最佳时机含冷冻期](#p1141)



#### 递归

[1006 - 合并两个有序链表](#p1006)

[1018 - 二叉树的中序遍历](#p1018)

[1032 - 二叉树的前序遍历](#p1032)

[1033 - 二叉树的后序遍历](#p1033)



#### 二分查找

[1010 - 搜索插入位置](#p1010)

[1014 - x的平方根](#p1014)

[1035 - 二分查找](#p1035)

[1040 - 长度最小的子数组](#p1040)



#### 位运算

[1013 - 二进制求和](#p1013)

[1030：只出现一次的数字](#p1030)



#### 滑动窗口

[1040 - 长度最小的子数组](#p1040)

[1060 - 滑动窗口的最大值](#p1060)

[1143 - 或值至少为K的最短子数组 II](#p1143)



#### 前缀和

[1040 - 长度最小的子数组](#p1040)



#### 模拟

[1041 - 螺旋矩阵 II](#p1041)



## 题目列表

### 1001 - 两数之和<a id="p1001"></a>

#### 题目

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。



**示例 1：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**示例 2：**

```
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

**示例 3：**

```
输入：nums = [3,3], target = 6
输出：[0,1]
```



#### 解法

暴力解法

```python
# 双层遍历
# 内部设置判断条件if

from ast import List


class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        length = len(nums)
        for i in range(length):
            for j in range(length):
                if nums[i] + nums[j] == target and i != j:
                    return[i,j]
        return[]
    

'''
    列表中的值是可以重复的，去重方法：转为set集合
    对于列表有默认方法len方法：可以获取指定列表的索引长度，获取的值即为列表的元素个数 - 1
    同时存在index方法：获取某个元素在列表中的索引（可指定范围，默认获取第一个相同的值的索引）
'''
```

字典法

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        records = {}
        for index, num in enumerate(nums):
            if (target - num) in records:
                return [index, records[target - num]]
            else:
                records[num] = index
```





### 1002 - 回文数<a id="p1002"></a>

#### 题目

给你一个整数 `x` ，如果 `x` 是一个回文整数，返回 `true` ；否则，返回 `false` 。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

- 例如，`121` 是回文，而 `123` 不是。

 

**示例 1：**

```
输入：x = 121
输出：true
```

**示例 2：**

```
输入：x = -121
输出：false
解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
```

**示例 3：**

```
输入：x = 10
输出：false
解释：从右向左读, 为 01 。因此它不是一个回文数。
```



#### 解法

```python
'''
    转换为字符串，比较字符串即可
    问题：内存较大
'''

class Solution:
    def isPalindrome(self, x: int) -> bool:
        if str(x) != reversed(str(x)):
            return False
        else:
            return True
```



### 1003 - 罗马数字转整数<a id="p1003"></a>

#### 题目

罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。

```
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```

例如， 罗马数字 `2` 写做 `II` ，即为两个并列的 1 。`12` 写做 `XII` ，即为 `X` + `II` 。 `27` 写做 `XXVII`, 即为 `XX` + `V` + `II` 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：

- `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。
- `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。 
- `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。

给定一个罗马数字，将其转换成整数。

 

**示例 1:**

```
输入: s = "III"
输出: 3
```

**示例 2:**

```
输入: s = "IV"
输出: 4
```

**示例 3:**

```
输入: s = "IX"
输出: 9
```

**示例 4:**

```
输入: s = "LVIII"
输出: 58
解释: L = 50, V= 5, III = 3.
```

**示例 5:**

```
输入: s = "MCMXCIV"
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.
```



#### 解法

```python
'''
    切割字符串
    设置字典
    遍历相加

    问题：如何切割？
    def romanToInt(self, s: str) -> int:
        d = {'I':1, 'IV':3, 'V':5, 'IX':8, 'X':10, 'XL':30, 'L':50, 'XC':80, 'C':100, 'CD':300, 'D':500, 'CM':800, 'M':1000}
        sum = 0
        for i,n in enumerate(s):
        sum += d.get(s[max(i-1, 0):i+1],d[n])
        return sum  

    思想：遍历，对于4、9之类的特殊字符，每次读取两位，如果不能寻找就加当前位
    对于开头存在特殊字符的处理：将特殊字符在字典内的值-1即可，实现对于重复加的处理
'''
class Solution:
    def romanToInt(self, s: str) -> int:
        d = {'I':1, 'IV':3, 'V':5, 'IX':8, 'X':10, 'XL':30, 'L':50, 'XC':80, 'C':100, 'CD':300, 'D':500, 'CM':800, 'M':1000}
        return sum(d.get(s[max(i-1, 0):i+1], d[n]) for i, n in enumerate(s))
```



### 1004 - 最长公共前缀<a id="p1004"></a>

#### 问题

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

 

**示例 1：**

```
输入：strs = ["flower","flow","flight"]
输出："fl"
```

**示例 2：**

```
输入：strs = ["dog","racecar","car"]
输出：""
解释：输入不存在公共前缀。
```



#### 解法

```python
'''
    对字符串进行遍历
    每次从首字母截取，拓展，一旦不匹配则返回值
'''

class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        char = ([strs[i] for i in range(len(strs))])

        for x in range(1,len(max(strs,key = len))):
            i = set([str[:x] for str in char])
            if len(i) > 1 and x == 1:
                return ''
            elif len(i) > 1:
                return char[1][:x - 1]
```



### 1005 - 有效的括号<a id="p1005"></a>

#### 问题

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

 

**示例 1：**

```
输入：s = "()"
输出：true
```

**示例 2：**

```
输入：s = "()[]{}"
输出：true
```

**示例 3：**

```
输入：s = "(]"
输出：false
```



#### 解法

列表天生就是栈，运用栈的思维解决问题

```python
'''
    转为列表
    使用字典 or 列表
    (,[,{,},],)
    回文数问题判断，不符False
'''
class Solution:
    def isValid(self, s: str) -> bool:
        # 简单逻辑判断，如果字符串个数并非偶数则直接不闭合
        if len(s) % 2 != 0:
            print("字符串长度不符合")
            return False
        
        # 创建列表记录括号数目，转为字符串判断回文数，若非回文数直接False
        Valid = [0,0,0,0,0,0]
        for i in s:
            if i == "(":
                Valid[0] += 1
            elif i == "[":
                Valid[1] += 1
            elif i == "{":
                Valid[2] += 1
            elif i == "}":
                Valid[3] += 1
            elif i == "]":
                Valid[4] += 1
            elif i == ")":
                Valid[5] += 1
        if ''.join([str(i) for i in Valid]) != ''.join([str(i) for i in Valid])[::-1]:
            print("逻辑不符合",Valid)
            print(''.join([str(i) for i in Valid]))
            print(reversed(''.join([str(i) for i in Valid])))
            return False
        else:

            print("正确")
            return True

    isValid("([)]",s="([)]")


'''
    以上方法仍然不成熟，使用栈才是最优解
    如何使用栈的思维处理该问题？
    基本操作：进栈 出栈

    栈先入后出特点恰好与本题括号排序特点一致，
    即若遇到左括号入栈，遇到右括号时将对应栈顶左括号出栈，
    则遍历完所有括号后 stack 仍然为空；
'''

class Solution:
    def isValid(self, s: str) -> bool:
        if len(s) % 2 != 0:
            # 字符串的长度不符合偶数
            return False
        dic = {'{': '}',  '[': ']', '(': ')'}
        stack = []
        for c in s:
            # 左括号则入栈
            if c in dic: stack.append(c)
            # 
            elif c != dic[stack.pop()]: 
                return False 
        return len(stack) == 0
```



### 1006 - 合并两个有序链表<a id="p1006"></a>

#### 题目

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

 

**示例 1：**

![img](./assets/merge_ex1.jpg)

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**示例 2：**

```
输入：l1 = [], l2 = []
输出：[]
```

**示例 3：**

```
输入：l1 = [], l2 = [0]
输出：[0]
```



#### 解法

初次解决链表问题，学会使用Python中的链表

```python
'''
    两个链表转化为列表
    直接进行排序
'''

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        result = ListNode()
        tail = result
        while list1 != None and list2 != None:
            if list1.val <= list2.val:
                tail.next = list1
                tail = tail.next
                list1 = list1.next
            else:
                tail.next = list2
                tail = tail.next
                list2 = list2.next
        tail.next = list1 if list1 is not None else list2
        return result.next
```



### 1007 - 删除有序数组中的重复项<a id="p1007"></a>

#### 题目

给你一个 **非严格递增排列** 的数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。然后返回 `nums` 中唯一元素的个数。

考虑 `nums` 的唯一元素的数量为 `k` ，你需要做以下事情确保你的题解可以被通过：

- 更改数组 `nums` ，使 `nums` 的前 `k` 个元素包含唯一元素，并按照它们最初在 `nums` 中出现的顺序排列。`nums` 的其余元素与 `nums` 的大小不重要。
- 返回 `k` 。

**判题标准:**

系统会用下面的代码来测试你的题解:

```
int[] nums = [...]; // 输入数组
int[] expectedNums = [...]; // 长度正确的期望答案

int k = removeDuplicates(nums); // 调用

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
```

如果所有断言都通过，那么您的题解将被 **通过**。

 

**示例 1：**

```
输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
```

**示例 2：**

```
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
```



#### 解法

对于列表可以转换为Set集合去重

```python
'''
    去重
    利用Set集合进行去重
    转换为List后再排序
'''
class Solution:
    def removeDuplicates(self, nums) -> int:
        if len(nums)  == 0: 
            return 0
        k =  1
        for  i in range(1, len(nums)):
             if nums[i] != nums[i - 1]:
                nums[k] = nums[i]
                k += 1
        return k
```



### 1008 - 移除元素<a id="p1008"></a>

#### 问题

给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组**。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

 

**说明:**

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

```
// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
int len = removeElement(nums, val);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```

 

**示例 1：**

```
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
```

**示例 2：**

```
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,3,0,4]
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
```



#### 解法

最终返回值是数组的长度

经典问题在于：
对于本体做出的删除操作，如空间复杂度为O(1)
在使用for循环(for i in nums)的条件下，对nums做出更改，实际上会产生错误：即(for i in nums)这一用法的底层实际上依然是(for i in range())

```python
# 朴素解法：计算nums中有多少符合条件的元素，再执行删除
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        numofint = 0
        for i in nums:
            if i == val:
                numofint += 1
        for i in range(numofint):
            nums.remove(val)
        return len(nums)

# 错误解法：对于for循环的使用理解
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        for i in nums:
            if i == val:
                nums.remove(i)
        return len(nums)

# 双指针解法
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        # k =  1
        # for  i in range(1, len(nums)):
        #      if nums[i] != nums[i - 1]:
        #         nums[k] = nums[i]
        #         k += 1
        # return k
        k = 0
        for i in range(len(nums)):
            if nums[i] != val:
                nums[k] = nums[i]
                k += 1
        return len(nums)

# while配合双指针解法，优于for+双指针
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        a = 0
        b = 0
        while a < len(nums):
            if nums[a] != val:
                nums[b] = nums[a]
                b += 1
            a += 1
        return b
    
# 快慢指针
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        # 快慢指针
        fast = 0  # 快指针
        slow = 0  # 慢指针
        size = len(nums)
        while fast < size:  # 不加等于是因为，a = size 时，nums[a] 会越界
            # slow 用来收集不等于 val 的值，如果 fast 对应值不等于 val，则把它与 slow 替换
            if nums[fast] != val:
                nums[slow] = nums[fast]
                slow += 1
            fast += 1
        return slow
```



### 1009 - 找出字符串中第一个匹配项的下标<a id="p1009"></a>

#### 问题

给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串的第一个匹配项的下标（下标从 0 开始）。如果 `needle` 不是 `haystack` 的一部分，则返回 `-1` 。

 

**示例 1：**

```
输入：haystack = "sadbutsad", needle = "sad"
输出：0
解释："sad" 在下标 0 和 6 处匹配。
第一个匹配项的下标是 0 ，所以返回 0 。
```

**示例 2：**

```
输入：haystack = "leetcode", needle = "leeto"
输出：-1
解释："leeto" 没有在 "leetcode" 中出现，所以返回 -1 。
```



#### 解法

```python
'''
    字符串可以使用in方法
'''
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        if needle not in haystack:
            return -1
        else:
            i = 0
            while True:
                if haystack[i:i + len(needle)] == needle:
                    return i
                i += 1
```



### 1010 - 搜索插入位置<a id="p1010"></a>

#### 问题

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 `O(log n)` 的算法。

 

**示例 1:**

```
输入: nums = [1,3,5,6], target = 5
输出: 2
```

**示例 2:**

```
输入: nums = [1,3,5,6], target = 2
输出: 1
```

**示例 3:**

```
输入: nums = [1,3,5,6], target = 7
输出: 4
```



#### 解法

调库

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        for i in nums:
            if target <= i:
                return nums.index(i)
        return len(nums)
```

二分法

问题：为什么最终返回left呢？

答：while循环终止，说明找不到或者已经返回了索引。所以此时left所在的位置就是要插入的位置。

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1

        while left <= right:
            middle = (left + right) // 2

            if nums[middle] < target:
                left = middle + 1
            elif nums[middle] > target:
                right = middle - 1
            else:
                return middle
        return left
```



### 1011 - 最后一个单词的长度<a id="p1011"></a>

#### 问题

给你一个字符串 `s`，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 **最后一个** 单词的长度。

**单词** 是指仅由字母组成、不包含任何空格字符的最大子字符串。

 

**示例 1：**

```
输入：s = "Hello World"
输出：5
解释：最后一个单词是“World”，长度为5。
```

**示例 2：**

```
输入：s = "   fly me   to   the moon  "
输出：4
解释：最后一个单词是“moon”，长度为4。
```

**示例 3：**

```
输入：s = "luffy is still joyboy"
输出：6
解释：最后一个单词是长度为6的“joyboy”。
```



#### 解法

```python
class Solution:
    def lengthOfLastWord(self, s: str) -> int:
        return len(s.split()[-1])
```



### 1012 - 加一<a id="p1012"></a>

#### 问题

给定一个由 **整数** 组成的 **非空** 数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储**单个**数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

 

**示例 1：**

```
输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。
```

**示例 2：**

```
输入：digits = [4,3,2,1]
输出：[4,3,2,2]
解释：输入数组表示数字 4321。
```

**示例 3：**

```
输入：digits = [0]
输出：[1]
```



#### 解法

```python
# 列表为主体
class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        if digits[-1] != 9:
            digits[-1] += 1
        else
            
        return digits
    
# 数据为主题
class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        # 计算出该数字为多少:列表字符串转数字
        nums = ""
        while digits:
            nums = nums + str(digits.pop(0))
        nums = int(nums) + 1
        return [int(x) for x in str(nums)]
```



### 1013 - 二进制求和<a id="p1013"></a>

#### 问题

给你两个二进制字符串 `a` 和 `b` ，以二进制字符串的形式返回它们的和。

 

**示例 1：**

```
输入:a = "11", b = "1"
输出："100"
```

**示例 2：**

```
输入：a = "1010", b = "1011"
输出："10101"
```



#### 解法

```python
class Solution:
    def addBinary(self, a: str, b: str) -> str:
        return bin(int(a, 2) + int(b, 2))[2:]
```



### 1014 - x的平方根<a id="p1014"></a>

#### 问题

给你一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。

由于返回类型是整数，结果只保留 **整数部分** ，小数部分将被 **舍去 。**

**注意：**不允许使用任何内置指数函数和算符，例如 `pow(x, 0.5)` 或者 `x ** 0.5` 。

 

**示例 1：**

```
输入：x = 4
输出：2
```

**示例 2：**

```
输入：x = 8
输出：2
解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。
```



#### 解法

```python
import math
class Solution:
    def mySqrt(self, x: int) -> int:
        return math.trunc(math.sqrt(x))
```



### 1015 - 爬楼梯<a id="p1015"></a>

#### 问题

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

 

**示例 1：**

```
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

**示例 2：**

```
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```



#### 解法

该题目涉及动态规划
使用数学思维：联想到斐波那契数列
建立数学函数：若爬上n层台阶，有f(n)种方法
其最后一次跳跃只有两种方法：跳一步和跳两步
所以f(n) = f(n - 1) + f(n - 2)
对于起步，很容易计算f(0) = 1,f(1) = 1
叠加即可计算

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        a , b = 1 , 1
        for _ in range(n - 1):
            a , b = b , a + b
        return b
```



### 1016 - 删除排序链表中的重复元素<a id="p1016"></a>

#### 问题

给定一个已排序的链表的头 `head` ， *删除所有重复的元素，使每个元素只出现一次* 。返回 *已排序的链表* 。

 

**示例 1：**

![img](./assets/list1.jpg)

```
输入：head = [1,1,2]
输出：[1,2]
```

**示例 2：**

![img](./assets/list2.jpg)

```
输入：head = [1,1,2,3,3]
输出：[1,2,3]
```



#### 解法

非双指针解法，思想一致，但是少开辟了空间，节省了内存

注意：要正确的判断条件，且考虑周全

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head:
            return head
        target = head
        while head and head.next:
            if head.val == head.next.val:
                head.next = head.next.next
            else:
                head = head.next
        return target
```

双指针解法

```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head == None:
            return head
        p = head
        q = p.next
        while q:
            if p.val == q.val:
                if q.next == None:
                    p.next = None
                    return head
                q = q.next
                p.next = q
            else:
                p = q
                q = q.next
        return head
```



### 1017 - 合并两个有序数组<a id="p1017"></a>

#### 问题

给你两个按 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。

请你 **合并** `nums2` 到 `nums1` 中，使合并后的数组同样按 **非递减顺序** 排列。

**注意：**最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。为了应对这种情况，`nums1` 的初始长度为 `m + n`，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 `0` ，应忽略。`nums2` 的长度为 `n` 。

 

**示例 1：**

```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。
```

**示例 2：**

```
输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
解释：需要合并 [1] 和 [] 。
合并结果是 [1] 。
```

**示例 3：**

```
输入：nums1 = [0], m = 0, nums2 = [1], n = 1
输出：[1]
解释：需要合并的数组是 [] 和 [1] 。
合并结果是 [1] 。
注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。
```



#### 解法

```python
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        # 覆盖方法
        # for i in range(m,m + n):
        #     nums1[i] = nums2[i - m]
        # nums1.sort()

        # 双指针
        k = m - 1
        l = n - 1
        x = m + n - 1
        while k >= 0 and l >= 0:
            if nums1[k] >= nums2[l]:
                nums1[x] = nums1[k]
                k -= 1
            else:
                nums1[x] = nums2[l]
                l -= 1
            x -= 1
        while l >= 0:
            nums1[x] = nums2[l]
            l -= 1
            x -= 1 
```





### 1018 - 二叉树的中序遍历<a id="p1018"></a>

#### 问题

给定一个二叉树的根节点 `root` ，返回 *它的 **中序** 遍历* 。

 

**示例 1：**

![img](./assets/inorder_1.jpg)

```
输入：root = [1,null,2,3]
输出：[1,3,2]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [1]
输出：[1]
```



#### 解法

方法一：使用递归方法

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []
        result = []
        def demo(target:Optional[TreeNode]):
            if target:
                demo(target.left)
                result.append(target.val)
                demo(target.right)
        demo(root)
        return result
```

方法二：使用迭代解法

```python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []
        temp = []
        result = []
        while root or temp:
            if root:
                temp.append(root)
                root = root.left
            else:
                temp1 = temp.pop()
                result.append(temp1.val)
                root = temp1.right
        return result
```

方法三：使用迭代模板

```python
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        result = []
        st = []
        if root:
            st.append(root)
        while st:
            node = st.pop()
            if node != None:
                if node.right: #添加右节点（空节点不入栈）
                    st.append(node.right)
                
                st.append(node) #添加中节点
                st.append(None) #中节点访问过，但是还没有处理，加入空节点做为标记。
                
                if node.left: #添加左节点（空节点不入栈）
                    st.append(node.left)
            else: #只有遇到空节点的时候，才将下一个节点放进结果集
                node = st.pop() #重新取出栈中元素
                result.append(node.val) #加入到结果集
        return result
```



### 1019 - 相同的树<a id="p1019"></a>

#### 问题

给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

 

**示例 1：**

![img](./assets/ex1.jpg)

```
输入：p = [1,2,3], q = [1,2,3]
输出：true
```

**示例 2：**

![img](./assets/ex2.jpg)

```
输入：p = [1,2], q = [1,null,2]
输出：false
```

**示例 3：**

![img](./assets/ex3.jpg)

```
输入：p = [1,2,1], q = [1,1,2]
输出：false
```



#### 解法

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        if not q and not p:
            return True
        if not p or not q:
            return False
        return p.val == q.val and self.isSameTree(p.right,q.right) and self.isSameTree(p.left,q.left)
```



### 1020 - 对称二叉树<a id="p1020"></a>

#### 问题

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

 

**示例 1：**

![img](./assets/1698026966-JDYPDU-image.png)

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

**示例 2：**

![img](./assets/1698027008-nPFLbM-image.png)

```
输入：root = [1,2,2,null,3,null,3]
输出：false
```



#### 解法

递归

```python
class Solution:
    def judge(self,rootleft:Optional[TreeNode],rootright:Optional[TreeNode]) -> bool:
            if not rootleft and not rootright:
                return True
            if not rootleft or not rootright:
                return False
            if rootleft.val != rootright.val:
                return False
            else:
                return self.judge(rootleft.left,rootright.right) and self.judge(rootleft.right,rootright.left)
            return True
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        return self.judge(root.left,root.right)
```

迭代

```python
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        from collections import deque
        deque = collections.deque()
        deque.append(root.left)
        deque.append(root.right)
        while deque:
            left = deque.popleft()
            right = deque.popleft()
            if not left and not right: #左节点为空、右节点为空，此时说明是对称的
                continue
            #左右一个节点不为空，或者都不为空但数值不相同，返回false
            if not left or not right or left.val != right.val:
                return False
            deque.append(left.left)
            deque.append(right.right)
            deque.append(left.right)
            deque.append(right.left)
        return True
```



### 1021 - 二叉树的最大深度<a id="p1021"></a>

#### 问题

给定一个二叉树 `root` ，返回其最大深度。

二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。

 

**示例 1：**

![img](./assets/tmp-tree.jpg)

 

```
输入：root = [3,9,20,null,null,15,7]
输出：3
```

**示例 2：**

```
输入：root = [1,null,2]
输出：2
```



#### 解法

递归解法

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def Judge(self, root) -> int:
        if not root:
            return 0
        elif not root.left and not root.right:
            return 1
        elif root.left and root.right:
            return max(1 + self.Judge(root.left),1 + self.Judge(root.right))
        elif root.left or root.right:
            return max((1 + self.Judge(root.left)),(1 + self.Judge(root.right)))
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        return self.Judge(root)
```

使用模板解法

```python
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        
        depth = 0
        queue = collections.deque([root])
        
        while queue:
            depth += 1
            for _ in range(len(queue)):
                node = queue.popleft()
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
        
        return depth
```



### 1022 - 将有序数组转换为二叉搜索树<a id="p1022"></a>

#### 问题

给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 **高度平衡** 二叉搜索树。

**高度平衡** 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。

 

**示例 1：**

![img](./assets/btree1.jpg)

```
输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：
```

**示例 2：**

![img](./assets/btree.jpg)

```
输入：nums = [1,3]
输出：[3,1]
解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。
```



#### 解法

递归创建二叉树，难点在于要平衡，所以要均分左右

其实只要每次寻找中间值就好

精妙之处在于无论奇数偶数，计算出的中间节点都是一样的：四舍五入；比如6和7

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        lenth = len(nums)
        # 二叉搜索树，左子树比根节点小，右子树比根节点大
        # 每次二分 递归
        # 创建二叉树
        def createTree(l , r) -> Optional[TreeNode]:
            if l > r:
                return None
            mid = (l + r) // 2
            tree = TreeNode(nums[mid])
            tree.left = createTree(l,mid - 1)
            tree.right = createTree(mid + 1,r)
            return tree
        return createTree(0,lenth - 1)
```



### 1023 - 平衡二叉树<a id="p1023"></a>

#### 问题

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

> 一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 。

 

**示例 1：**

![img](./assets/balance_1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：true
```

**示例 2：**

![img](./assets/balance_2.jpg)

```
输入：root = [1,2,2,3,3,null,null,4,4]
输出：false
```

**示例 3：**

```
输入：root = []
输出：true
```



#### 解法

普通方法：

lenth方法用来计算树的深度

再判断左右树的深度差绝对值即可。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left 
#         self.right = right
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        # 判断的是每个节点的左右子树的高度差
        # 而不是整棵树最高节点和最低节点的高度差
        # 将树分为左右，判断左右即可
        def lenth(root) -> int:
            if not root:
                return 0
            elif not root.left and not root.right:
                return 1
            elif root.left and root.right:
                return max(1 + lenth(root.left),1 + lenth(root.right))
            elif root.left or root.right:
                return max((1 + lenth(root.left)),(1 + lenth(root.right)))
        def Judge(root):
            if not root or (not root.left and not root.right):
                return True
            if abs(lenth(root.left) - lenth(root.right)) > 1:
                return False
            else:
                return Judge(root.left) and Judge(root.right)
        return Judge(root)
```

剪枝法：

该方法即使用了最简单的方法统计了树的高度，同时还可以判定树是否为平衡二叉树。

对于recur函数，其有两个作用：1.探查树的深度 2.判断树是否为平衡树

关于其第一个作用不做解释，就是判断深度。

但是其第二个作用的实现，很为精妙：首先，`if left == -1: return -1`和`if right == -1: return -1`两句，实现的功能是，一旦发现有不平衡的部分，则全局返回-1来判断此树不是平衡树；其次，其每次探查完左右子树的长度后立即比对是否为平衡树，可以立即返回结果；最后，这种极为巧妙地层级设计帮助一旦遇到非平衡情况能全局返回最终结果。

对待这个函数要全局来看：仅从第一层来看的话，其比较的是左右两侧的最大值的长度，直觉上不能比较是否平衡，但是实际上，其完全遍历了树的左右，是正确的。

```python
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        def recur(root):
            if not root: return 0
            left = recur(root.left)
            if left == -1: return -1
            right = recur(root.right)
            if right == -1: return -1
            return max(left, right) + 1 if abs(left - right) <= 1 else -1

        return recur(root) != -1
```



### 1024 - 二叉树的最小深度<a id="p1024"></a>

#### 问题

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明：**叶子节点是指没有子节点的节点。

 

**示例 1：**

![img](./assets/ex_depth.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：2
```

**示例 2：**

```
输入：root = [2,null,3,null,4,null,5,null,6]
输出：5
```



#### 解法

递归：

整棵树遍历返回最小深度

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        elif not root.left and not root.right:
            return 1
        elif not root.left:
            return self.minDepth(root.right) + 1
        elif not root.right:
            return self.minDepth(root.left) + 1
        else:
            return min(self.minDepth(root.right) + 1,self.minDepth(root.left) + 1)
        return self.minDepth(root) + 1
```

迭代：

该迭代方法中，使用了栈（列表）储存元组的方法，每次读取列表中最后的元组，来记录深度和节点对象（中间值）。

直到最先找到某个节点是叶子节点即可：最先找到的必定最小。

```python
class Solution:
    def minDepth(self, root):
        if not root:
            return 0
        
        deque = []
        deque.append((1, root))
        
        while deque:
            depth, root = deque.pop(0) 
            # 判断是否是叶子节点
            if not root.left and not root.right:
                return depth    
            # 非空记录节点+深度
            if root.left:deque.append((depth+1, root.left))
            if root.right:deque.append((depth+1, root.right))
```

模板

```python
class Solution:
    def minDepth(self, root):
        if not root:
        	return 0
        from collections import deque
        deque = collections.deque([root])
        result = 0
        while deque:
            result += 1
            for _ in range(len(deque)):
                node = deque.popleft()
                if not node.left and not node.right:
                    return result
                if node.left:
                    deque.append(node.left)
                if node.right:
                    deque.append(node.right)
```





### 1025 - 路径总和<a id="p1025"></a>

#### 问题

给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。

**叶子节点** 是指没有子节点的节点。

 

**示例 1：**

![img](./assets/pathsum1.jpg)

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
解释：等于目标和的根节点到叶节点路径如上图所示。
```

**示例 2：**

![img](./assets/pathsum2.jpg)

```
输入：root = [1,2,3], targetSum = 5
输出：false
解释：树中存在两条根节点到叶子节点的路径：
(1 --> 2): 和为 3
(1 --> 3): 和为 4
不存在 sum = 5 的根节点到叶子节点的路径。
```

**示例 3：**

```
输入：root = [], targetSum = 0
输出：false
解释：由于树是空的，所以不存在根节点到叶子节点的路径。
```



#### 解法

递归，找到某个路径的节点总和是否为某个特定值，可以将问题转化为是否有一条路可以在到达叶子节点的时候将目标值减为0。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if not root:
            return False
        else:
            if root.left and root.right:
                return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)
            elif not root.left and not root.right and targetSum - root.val == 0:
                return True
            else:
                return self.hasPathSum(root.left, targetSum - root.val) if root.left else self.hasPathSum(root.right, targetSum - root.val)
```

递归精简

```python
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if not root:
            return False
        if not root.left and not root.right and targetSum == root.val:
            return True
        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)
```

迭代

```python
class Solution:
    def hasPathSum(self, root: TreeNode, sum: int) -> bool:
        if not root:
            return False
        # 此时栈里要放的是pair<节点指针，路径数值>
        st = [(root, root.val)]
        while st:
            node, path_sum = st.pop()
            # 如果该节点是叶子节点了，同时该节点的路径数值等于sum，那么就返回true
            if not node.left and not node.right and path_sum == sum:
                return True
            # 右节点，压进去一个节点的时候，将该节点的路径数值也记录下来
            if node.right:
                st.append((node.right, path_sum + node.right.val))
            # 左节点，压进去一个节点的时候，将该节点的路径数值也记录下来
            if node.left:
                st.append((node.left, path_sum + node.left.val))
        return False
```



### 1026 - 杨辉三角<a id="p1026"></a>

#### 问题

给定一个非负整数 *`numRows`，*生成「杨辉三角」的前 *`numRows`* 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。

![img](./assets/1626927345-DZmfxB-PascalTriangleAnimated2.gif)

 

**示例 1:**

```
输入: numRows = 5
输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
```

**示例 2:**

```
输入: numRows = 1
输出: [[1]]
```



#### 解法

杨辉三角的一个特点是：左右恒为1

而且其某层的元素就是上一个列表的相邻值相加得来，所以核心代码在于根据上一层计算出下一层

有意思的是：解决杨辉三角每层左右都是1的方法是先添加1，执行完核心代码再添加1

```python
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        # 最左和最右 + 1
        # 每次将上层列表的值 求和
        result = [[1]]
        for i in range(1, numRows):
            temp = [1]
            # 获取上层列表
            last_lst = result[i - 1]
            for j in range(1, len(last_lst)):
                temp.append(last_lst[j] + last_lst[j - 1])
            temp.append(1)
            result.append(temp)
        return result
```



### 1027 - 杨辉三角 II<a id="p1027"></a>

#### 问题

给定一个非负索引 `rowIndex`，返回「杨辉三角」的第 `rowIndex` 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。

![img](./assets/1626927345-DZmfxB-PascalTriangleAnimated2-1709296357890-7.gif)

 

**示例 1:**

```
输入: rowIndex = 3
输出: [1,3,3,1]
```

**示例 2:**

```
输入: rowIndex = 0
输出: [1]
```

**示例 3:**

```
输入: rowIndex = 1
输出: [1,1]
```



#### 解法

比上一题多计算一层并返回最后一层即可

```python
class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        # 最左和最右 + 1
        # 每次将上层列表的值 求和
        result = [[1]]
        for i in range(1, rowIndex + 1):
            temp = [1]
            # 获取上层列表
            last_lst = result[i - 1]
            for j in range(1, len(last_lst)):
                temp.append(last_lst[j] + last_lst[j - 1])
            temp.append(1)
            result.append(temp)
        return result[-1]
```



### 1028 - 买卖股票的最佳时机<a id="p1028"></a>

#### 问题

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

 

**示例 1：**

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

**示例 2：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
```



#### 解法

本题暴力解法最简单，但是很容易超时

方法一：很好理解，每次记录自遍历开始的最低价格和最大差值

其中，先获得最低价格后再计算最大差值，可以保证永远不会减出负数，避免了高买低出

方法二：贪心算法

​		精髓在于相较于方法一减小了计算量，其核心思想是，假设第一天为最低价格，向后遍历，遇到更低的价格就将更新最低价格，遇到不是最低的价格就直接使用今日价格减最低价格获得答案，答案随着遍历更新。

至于其减少的计算量就是：方法一在最低价格更新后还会相减一次，结果必为0，没有意义。

方法三：动态规划算法

​		对于dp数组，其内部存储的是当天是否持有股票的最大收益。以此推算即可。

```python
# class Solution:
#     def maxProfit(self, prices: List[int]) -> int:
#         # 锚定某天买入，推以后最大值卖出
#         # 暴力解法：超时
#         lenth = len(prices)
#         lst = []
#         for i in range(lenth):
#             lst.append(max(prices[j] for j in range(i, lenth)) - prices[i])
#         return max(lst)

# 方法一
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if not prices:
            return 0
        minprice = prices[0]
        maxprofit = 0
        for price in prices:
            minprice = min(minprice, price)
            maxprofit = max(maxprofit, price - minprice)
        return maxprofit

# 方法二
# 贪心
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if not prices:
            return 0
        ans=0
        curmin = prices[0]
        for v in prices:
            if v<curmin:
                curmin=v
            else:
                ans=max(ans, v-curmin)
        return ans
    
# 动态规划算法
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # dp数组代表当天是否持有股票，0代表不持有股票，1代表持有股票
        dp = [[0] * 2 for _ in range(len(prices))]
        dp[0] = [0, -prices[0]]
        for i in range(1, len(prices)):
            # 对于当天不持有股票有两种状态：1、像昨天一样不持有股票手中的现金 2、今日卖出
            # 对于当天持有股票有两种状态：1、和昨天一样 2、今日买入
            dp[i] = [max(dp[i - 1][0], prices[i] + dp[i - 1][1]), max(dp[i - 1][1], -prices[i])]
        return max(dp[-1])
```



### 1029 - 验证回文串<a id="p1029"></a>

#### 问题

如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 **回文串** 。

字母和数字都属于字母数字字符。

给你一个字符串 `s`，如果它是 **回文串** ，返回 `true` ；否则，返回 `false` 。

 

**示例 1：**

```
输入: s = "A man, a plan, a canal: Panama"
输出：true
解释："amanaplanacanalpanama" 是回文串。
```

**示例 2：**

```
输入：s = "race a car"
输出：false
解释："raceacar" 不是回文串。
```

**示例 3：**

```
输入：s = " "
输出：true
解释：在移除非字母数字字符之后，s 是一个空字符串 "" 。
由于空字符串正着反着读都一样，所以是回文串。
```



#### 解法

两种方法区别在于如何校验是否是回文串

目前调库快于双指针

```python
class Solution:
    def isPalindrome(self, s: str) -> bool:
        # 调库高手:更快
        # 处理字符串：根据ASCII码，只加入字母，对大写字母处理
        lst = []
        for i in s:
            if (ord(i) >= 97 and ord(i) <= 122) or (ord(i) >= 48 and ord(i) <= 57):
                lst.append(i)
            elif ord(i) >= 65 and ord(i) <= 90:
                lst.append(chr(ord(i) + 32))
        
        new_s = "".join(lst)
        return new_s == new_s[::-1]

        # 双指针
        lst = []
        for i in s:
            if (ord(i) >= 97 and ord(i) <= 122) or (ord(i) >= 48 and ord(i) <= 57):
                lst.append(i)
            elif ord(i) >= 65 and ord(i) <= 90:
                lst.append(chr(ord(i) + 32))

        lenth = len(lst)
        for i in range(lenth // 2):
            if lst[i] == lst[lenth - 1]:
                lenth -= 1
            else:
                return False
        return True
```



### 1030 - 只出现一次的数字<a id="p1030"></a>

#### 问题

给你一个 **非空** 整数数组 `nums` ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。

 

**示例 1 ：**

```
输入：nums = [2,2,1]
输出：1
```

**示例 2 ：**

```
输入：nums = [4,1,2,1,2]
输出：4
```

**示例 3 ：**

```
输入：nums = [1]
输出：1
```



#### 解法

位运算：对二进制形式的数字进行位运算，如果两个数字相同则返回0，如果不同则返回两个二进制数的不同之处（由两个二进制数字的1填充）

异或运算的精髓在于：其符合交换律，比如a ^ b = b ^ a。

对于本题目而言：若出现数组[2, 2, 1, 4, 4]，无需在意1 ^ 4的结果，因为最后其还要有1 ^ 4 ^ 4 运算，最终结果还是1。

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        # 暴力破解
        # 10%
        lenth = len(nums)
        if lenth == 1:
            return nums[0]
        lst = []
        for i in range(lenth):
            if nums[i] not in lst:
                lst.append(nums[i])
            else:
                lst.remove(nums[i])
        return lst[0]

        # 位运算
        lenth = len(nums)
        if lenth == 1: return nums[0]
        result = nums[0]
        for i in range(1, lenth):
            result = result ^ nums[i]
        return result
```



### 1031 - 环形链表<a id="p1031"></a>

#### 问题

给你一个链表的头节点 `head` ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：`pos` 不作为参数进行传递** 。仅仅是为了标识链表的实际情况。

*如果链表中存在环* ，则返回 `true` 。 否则，返回 `false` 。

 

**示例 1：**

![img](./assets/circularlinkedlist.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例 2：**

![img](./assets/circularlinkedlist_test2.png)

```
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
```

**示例 3：**

![img](./assets/circularlinkedlist_test3.png)

```
输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
```



#### 解法

暴力解法：数据量有范围，选最大范围处理即可。

双指针解法：快的指针终将追上慢的指针，它们之间的相对距离以1的距离缩减。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

# 暴力解法
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        index = 0
        while index < 10001:
            if not head:
                return False
            head = head.next
            index += 1
        return True

# 快慢指针：快的指针必定会追上慢的指针
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        slow = fast = head
        while fast:
            if fast.next:
                fast = fast.next.next
            else:
                break
            slow = slow.next
            if fast == slow:
                return True
        return False
```



### 1032 - 二叉树的前序遍历<a id="p1032"></a>

#### 问题

给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

 

**示例 1：**

![img](./assets/inorder_1-1709551183284-1.jpg)

```
输入：root = [1,null,2,3]
输出：[1,2,3]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [1]
输出：[1]
```

**示例 4：**

![img](./assets/inorder_5.jpg)

```
输入：root = [1,2]
输出：[1,2]
```

**示例 5：**

![img](./assets/inorder_4.jpg)

```
输入：root = [1,null,2]
输出：[1,2]
```

 

**提示：**

- 树中节点数目在范围 `[0, 100]` 内
- `-100 <= Node.val <= 100`

 

**进阶：**递归算法很简单，你可以通过迭代算法完成吗？



#### 解法

递归

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        result = []
        def preorder(root: Optional[TreeNode]):
            if not root:
                return
            result.append(root.val)
            preorder(root.left)
            preorder(root.right)
        preorder(root)
        return result
```

使用迭代模板

```python
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        result = []
        st = []
        if root:
            st.append(root)
        while st:
            node = st.pop()
            if node != None:
                if node.right: #右
                    st.append(node.right)
                if node.left: #左
                    st.append(node.left)
                st.append(node) #中
                st.append(None)
            else:
                node = st.pop()
                result.append(node.val)
        return result
```



### 1033 - 二叉树的后序遍历<a id="p1033"></a>

#### 问题

给你一棵二叉树的根节点 `root` ，返回其节点值的 **后序遍历** 。

 

**示例 1：**

![img](./assets/pre1.jpg)

```
输入：root = [1,null,2,3]
输出：[3,2,1]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [1]
输出：[1]
```

 

**提示：**

- 树中节点的数目在范围 `[0, 100]` 内
- `-100 <= Node.val <= 100`

 

**进阶：**递归算法很简单，你可以通过迭代算法完成吗？



#### 解法

递归

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        lst = []
        def posoder(root: Optional[TreeNode]):
            if root and root.left:
                posoder(root.left)
            if root and root.right:
                posoder(root.right)
            if root:
                lst.append(root.val)
        posoder(root)
        return lst
```

迭代模板

```python
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        result = []
        st = []
        if root:
            st.append(root)
        while st:
            node = st.pop()
            if node != None:
                st.append(node) #中
                st.append(None)
                
                if node.right: #右
                    st.append(node.right)
                if node.left: #左
                    st.append(node.left)
            else:
                node = st.pop()
                result.append(node.val)
        return result
```



### 1034 - 两数相加<a id="p1034"></a>

#### 问题

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

 

**示例 1：**

![img](./assets/addtwonumber1.jpg)

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

**示例 2：**

```
输入：l1 = [0], l2 = [0]
输出：[0]
```

**示例 3：**

```
输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
```



#### 解法

思路
将两个链表转换成长度相等的两数相加，在短链表前补0，例如123+1转换成123+001=124。而由于本题中链表是逆序存储数字的，因此是在链表的尾部补0。之后，类似于手写竖式加法，逐位相加，记录每位的进位与余数即可。

解法
在链表题中，常用的方法是先定义一个dummy节点，这样可以避免对头节点的特殊处理。需要注意的是，在遍历结束后，如果carry不为0，需要在链表最后增加一个节点，例如99+01=100，结果100中的1就是最后的进位。

```python
# 增补法
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        result = ListNode()
        res = result
        jw = 0
        while l1 or l2:
            sum = (l1.val if l1 else 0) + (l2.val if l2 else 0) + jw
            jw = sum // 10
            res.next = ListNode(sum - 10 if sum >= 10 else sum)
            res = res.next
            if l1:
                l1 = l1.next
            if l2:
                l2 = l2.next
        if jw:
            res.next = ListNode(1)
        return result.next
```



### 1035 - 二分查找<a id="p1035"></a>

#### 问题

给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target` ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。


**示例 1:**

```
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

**示例 2:**

```
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```



#### 解法

调库

```python
# 调库
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        return nums.index(target) if target in nums else -1
```

正常写法

```python
# 正常写法
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        lenth = len(nums)
        head = lenth - 1
        tail = 0
        while True:
            if head < tail:
                return -1
            mid = (head - tail) // 2 + tail
            if nums[mid] == target:
                return mid
            elif nums[mid] > target:
                head = mid - 1
            elif nums[mid] < target:
                tail = mid + 1
```



### 1036 - 反转字符串<a id="p1036"></a>

#### 问题

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。

不要给另外的数组分配额外的空间，你必须**[原地](https://baike.baidu.com/item/原地算法)修改输入数组**、使用 O(1) 的额外空间解决这一问题。

 

**示例 1：**

```
输入：s = ["h","e","l","l","o"]
输出：["o","l","l","e","h"]
```

**示例 2：**

```
输入：s = ["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]
```



#### 解法

双指针解法

```python
class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        # 双指针
        tail, head = 0, len(s) - 1
        for i in range(head + 1):
            if head <= tail:
                break
            temp = s[tail]
            s[tail] = s[head]
            s[head] = temp
            tail, head = tail + 1, head - 1
```

调库

对于使用`[::-1]`切片方法其本质上是返回一个新的数组，而是用`reverse`方法则是直接在内存上做出修改。

```python
class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        # 调库
        return s.reverse()
```





### 1037 - 反转字符串 II<a id="p1037"></a>

#### 问题

给定一个字符串 `s` 和一个整数 `k`，从字符串开头算起，每计数至 `2k` 个字符，就反转这 `2k` 字符中的前 `k` 个字符。

- 如果剩余字符少于 `k` 个，则将剩余字符全部反转。
- 如果剩余字符小于 `2k` 但大于或等于 `k` 个，则反转前 `k` 个字符，其余字符保持原样。

 

**示例 1：**

```
输入：s = "abcdefg", k = 2
输出："bacdfeg"
```

**示例 2：**

```
输入：s = "abcd", k = 2
输出："bacd"
```



#### 解法

普通解法

```python
# 每隔着k个字符记录，反转偶数数
class Solution:
    def reverseStr(self, s: str, k: int) -> str:
        lst = []
        temp = []
        for i in range(len(s)):
            if i % k == 0:
                lst.append(temp)
                temp = []
            temp.append(s[i])
        if temp:
            lst.append(temp)
        lst.pop(0)
        result = ""
        for i in range(len(lst)):
            temp = ""
            for char in lst[i]:
                temp = temp + char
            if i % 2 == 0:
                result = result + temp[::-1]
            else:
                result = result + temp
        return result
```

字符串拼接

```python
# 利用python对于字符串可操作的特性
class Solution:
    def reverseStr(self, s: str, k: int) -> str:
        s = s[k - 1::-1] + s[k:]
        for i in range(2 * k, len(s), 2 * k):
            s = s[0:i:] + s[i + k - 1:i - 1:-1] + s[i + k:len(s):]
        return s
```

简写

```python
# 简写
class Solution:
    def reverseStr(self, s: str, k: int) -> str:
        return "".join(s[i:i + k][::(-1 if i // k % 2 == 0 else 1)] for i in range(0, len(s), k))
```



### 1038 - 有序数组的平方<a id="p1038"></a>

#### 问题

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。



**示例 1：**

```
输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]
```

**示例 2：**

```
输入：nums = [-7,-3,2,3,11]
输出：[4,9,9,49,121]
```



#### 解法

```python
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        # 调库
        for i in range(len(nums)):
            nums[i] *= nums[i]
        nums.sort()
        return nums

        # 双指针
        l, r, k = 0, len(nums) - 1, len(nums) - 1
        result = [0] * len(nums)
        while k >= 0:
            if nums[l] * nums[l] >= nums[r] * nums[r]:
                result[k] = nums[l] * nums[l]
                l += 1
            else:
                result[k] = nums[r] * nums[r]
                r -= 1
            k -= 1
        return result
```



### 1039 - 密钥格式化<a id="p1039"></a>

#### 问题

给定一个许可密钥字符串 `s`，仅由字母、数字字符和破折号组成。字符串由 `n` 个破折号分成 `n + 1` 组。你也会得到一个整数 `k` 。

我们想要重新格式化字符串 `s`，使每一组包含 `k` 个字符，除了第一组，它可以比 `k` 短，但仍然必须包含至少一个字符。此外，两组之间必须插入破折号，并且应该将所有小写字母转换为大写字母。

返回 *重新格式化的许可密钥* 。

 

**示例 1：**

```
输入：S = "5F3Z-2e-9-w", k = 4
输出："5F3Z-2E9W"
解释：字符串 S 被分成了两个部分，每部分 4 个字符；
     注意，两个额外的破折号需要删掉。
```

**示例 2：**

```
输入：S = "2-5g-3-J", k = 2
输出："2-5G-3J"
解释：字符串 S 被分成了 3 个部分，按照前面的规则描述，第一部分的字符可以少于给定的数量，其余部分皆为 2 个字符。
```



#### 解法

调库

```python
# 字符串
class Solution:
    def licenseKeyFormatting(self, s: str, k: int) -> str:
        s = s.upper().replace('-', '')[::-1]
        nub = 0
        res = ''
        for i in range(0, len(s), k):
            res += s[i:i+k] + '-'
        return res[::-1].lstrip('-')
```



### 1040 - 长度最小的子数组<a id="p1040"></a>

#### 问题

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其总和大于等于 `target` 的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

 

**示例 1：**

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

**示例 2：**

```
输入：target = 4, nums = [1,4,4]
输出：1
```

**示例 3：**

```
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
```



#### 解法

滑动窗口方法

窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。

窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。

**滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。**

内部的while也是高明的地方：当累加值大于目标值后的处理，即左侧指针可能不止要移动一次。

```python
class Solution:
    def minSubArrayLen(self, s: int, nums: List[int]) -> int:
        l = len(nums)
        left = 0
        right = 0
        min_len = float('inf')
        cur_sum = 0 #当前的累加值
        
        while right < l:
            cur_sum += nums[right]
            
            while cur_sum >= s: # 当前累加值大于目标值
                min_len = min(min_len, right - left + 1)
                cur_sum -= nums[left]
                left += 1
            
            right += 1
        
        return min_len if min_len != float('inf') else 0
```



### 1041 - 螺旋矩阵 II<a id="#p1041"></a>

#### 问题

给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

 

**示例 1：**

![img](./assets/spiraln.jpg)

```
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]
```

**示例 2：**

```
输入：n = 1
输出：[[1]]
```



#### 解法

```python
# 模拟过程
class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        # 外层每次遍历的长度实际上是n - 1
        # 遍历完一层之后，下一层遍历的长度为 - 1
        # 模拟的顺序为：右  下  左  上
        max_lenth = n - 1    # 阈值
        result = [[-1 for _ in range(n)] for _ in range(n)]   # 初始化列表
        x, y = 0, 0     # 代表遍历坐标
        num = 1     # 需要叠加的值
        while max_lenth > 0:
            # 向右遍历
            for i in range(max_lenth):
                result[x][y] = num
                num += 1
                y += 1
            # 向下遍历
            for i in range(max_lenth):
                result[x][y] = num
                num += 1
                x += 1
            # 向左遍历
            for i in range(max_lenth):
                result[x][y] = num
                num += 1
                y -= 1
            # 向上遍历
            for i in range(max_lenth):
                result[x][y] = num
                num += 1
                x -= 1
            x += 1
            y += 1
            max_lenth -= 2
        if n % 2:
            result[n // 2][n // 2] = num
        return result
```



### 1042 - 移除链表元素<a id="p1042"></a>

#### 问题

给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。

 

**示例 1：**

![img](./assets/removelinked-list.jpg)

```
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
```

**示例 2：**

```
输入：head = [], val = 1
输出：[]
```

**示例 3：**

```
输入：head = [7,7,7,7], val = 7
输出：[]
```



#### 解法

```python
class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        if not head:
            return None
        result = ListNode(next = head)
        head = result
        while head.next:
            if head.next.val == val:
                head.next = head.next.next
            else:
                head = head.next
        
        return result.next
```



### 1043 - 设计链表<a id="p1043"></a>

#### 问题

你可以选择使用单链表或者双链表，设计并实现自己的链表。

单链表中的节点应该具备两个属性：`val` 和 `next` 。`val` 是当前节点的值，`next` 是指向下一个节点的指针/引用。

如果是双向链表，则还需要属性 `prev` 以指示链表中的上一个节点。假设链表中的所有节点下标从 **0** 开始。

实现 `MyLinkedList` 类：

- `MyLinkedList()` 初始化 `MyLinkedList` 对象。
- `int get(int index)` 获取链表中下标为 `index` 的节点的值。如果下标无效，则返回 `-1` 。
- `void addAtHead(int val)` 将一个值为 `val` 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。
- `void addAtTail(int val)` 将一个值为 `val` 的节点追加到链表中作为链表的最后一个元素。
- `void addAtIndex(int index, int val)` 将一个值为 `val` 的节点插入到链表中下标为 `index` 的节点之前。如果 `index` 等于链表的长度，那么该节点会被追加到链表的末尾。如果 `index` 比长度更大，该节点将 **不会插入** 到链表中。
- `void deleteAtIndex(int index)` 如果下标有效，则删除链表中下标为 `index` 的节点。

 

**示例：**

```
输入
["MyLinkedList", "addAtHead", "addAtTail", "addAtIndex", "get", "deleteAtIndex", "get"]
[[], [1], [3], [1, 2], [1], [1], [1]]
输出
[null, null, null, null, 2, null, 3]

解释
MyLinkedList myLinkedList = new MyLinkedList();
myLinkedList.addAtHead(1);
myLinkedList.addAtTail(3);
myLinkedList.addAtIndex(1, 2);    // 链表变为 1->2->3
myLinkedList.get(1);              // 返回 2
myLinkedList.deleteAtIndex(1);    // 现在，链表变为 1->3
myLinkedList.get(1);              // 返回 3
```



#### 解法

```python
class Node:
    def __init__(self, val = 0, next = None) -> None:
        self.val = val
        self.next = next

class MyLinkedList:

    def __init__(self):
        prenode = Node()
        self.head = prenode

    def get(self, index: int) -> int:
        # 根据索引获取当前的值
        headnode = self.head.next
        while index > 0:
            if not headnode:
                return -1
            headnode = headnode.next
            index -= 1
        if not headnode:
            return -1
        return headnode.val

    def addAtHead(self, val: int) -> None:
        # 增添头节点
        prenode = self.head
        temp = Node(val=val)
        temp.next = prenode.next
        prenode.next = temp

    def addAtTail(self, val: int) -> None:
        # 添加尾节点
        headnode = self.head
        while headnode and headnode.next:
            headnode = headnode.next
        headnode.next = Node(val = val)

    def addAtIndex(self, index: int, val: int) -> None:
        # 根据索引添加元素：如果 index 比长度更大，该节点将 不会插入 到链表中。
        headnode = self.head    # 此处代表虚拟节点
        for i in range(index):
            if not headnode:
                return
            headnode = headnode.next
        if not headnode:
            return
        temp = Node(val, headnode.next if headnode.next else None)
        headnode.next = temp
        

    def deleteAtIndex(self, index: int) -> None:
        # 根据索引删除元素：如果下标有效，则删除链表中下标为 index 的节点。
        # 三种情况：删除正常元素、删除最后一个元素、删除越界节点
        headnode = self.head    # 此处代表虚拟节点
        for i in range(index):
            if not headnode:
                return
            headnode = headnode.next
        if not headnode:
            return
        elif headnode and not headnode.next:
            headnode.next = None
        else:
            headnode.next = headnode.next.next
```



### 1044 - 反转链表<a id="p1044"></a>

#### 问题

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

 

**示例 1：**

![img](./assets/rev1ex1.jpg)

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

**示例 2：**

![img](./assets/rev1ex2.jpg)

```
输入：head = [1,2]
输出：[2,1]
```

**示例 3：**

```
输入：head = []
输出：[]
```



#### 解法

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next:
            return head
        # 三指针
        next_node = head.next
        head.next = None
        while next_node:
            temp = next_node.next
            next_node.next = head
            head = next_node
            next_node = temp
        return head
```



### 1045 - 两两交换链表中的节点<a id="p1045"></a>

#### 问题

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

 

**示例 1：**

![img](./assets/swap_ex1.jpg)

```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

**示例 2：**

```
输入：head = []
输出：[]
```

**示例 3：**

```
输入：head = [1]
输出：[1]
```



#### 解法

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # while循环判断条件，遇到head为空或next为空终止即可
        if not head or not head.next:
            return head
        result = head.next
        last_temp = ListNode()
        while head and head.next:
            temp = head.next
            last_temp.next = temp
            head.next = temp.next
            last_temp = head
            temp.next = head
            head = head.next
        return result
```



### 1046 - 删除链表的倒数第N个节点<a id="p1046"></a>

#### 问题

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

 

**示例 1：**

![img](./assets/remove_ex1.jpg)

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```

**示例 2：**

```
输入：head = [1], n = 1
输出：[]
```

**示例 3：**

```
输入：head = [1,2], n = 1
输出：[1]
```



#### 解法

快慢指针

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        # fast要比slow快 n + 1 步
        Prenode = ListNode(next = head)
        result = Prenode
        fast = head
        while n - 1:
            fast = fast.next
            n = n - 1
        while fast.next:
            Prenode = Prenode.next
            fast = fast.next
        Prenode.next = Prenode.next.next
        return result.next
```



### 1047 - 链表相交<a id="p1046"></a>

#### 问题

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交**：**

[![img](./assets/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

 

**示例 1：**

[![img](./assets/160_example_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```

**示例 2：**

[![img](./assets/160_example_2.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png)

```
输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Intersected at '2'
解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
```

**示例 3：**

[![img](./assets/160_example_3.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png)

```
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
这两个链表不相交，因此返回 null 。
```



#### 解法

求长度后，从距离尾部等长的位置遍历

代码随想录：

简单来说，就是求两个链表交点节点的**指针**。 这里同学们要注意，交点不是数值相等，而是指针相等。

为了方便举例，假设节点元素数值相等，则节点指针相等。

看如下两个链表，目前curA指向链表A的头结点，curB指向链表B的头结点：

![面试题02.07.链表相交_1](./assets/面试题02.07.链表相交_1.png)

我们求出两个链表的长度，并求出两个链表长度的差值，然后让curA移动到，和curB 末尾对齐的位置，如图：

![面试题02.07.链表相交_2](./assets/面试题02.07.链表相交_2.png)

此时我们就可以比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，如果遇到curA == curB，则找到交点。

否则循环退出返回空指针。

```python
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* curA = headA;
        ListNode* curB = headB;
        int lenA = 0, lenB = 0;
        while (curA != NULL) { // 求链表A的长度
            lenA++;
            curA = curA->next;
        }
        while (curB != NULL) { // 求链表B的长度
            lenB++;
            curB = curB->next;
        }
        curA = headA;
        curB = headB;
        // 让curA为最长链表的头，lenA为其长度
        if (lenB > lenA) {
            swap (lenA, lenB);
            swap (curA, curB);
        }
        // 求长度差
        int gap = lenA - lenB;
        // 让curA和curB在同一起点上（末尾位置对齐）
        while (gap--) {
            curA = curA->next;
        }
        // 遍历curA 和 curB，遇到相同则直接返回
        while (curA != NULL) {
            if (curA == curB) {
                return curA;
            }
            curA = curA->next;
            curB = curB->next;
        }
        return NULL;
    }
};
```

莫比乌斯环：一个链表到尾部后反转到另一个链表的头部，最终即便两个链表不等长，也会弥补。

```python
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        # 处理边缘情况
        if not headA or not headB:
            return None
        
        # 在每个链表的头部初始化两个指针
        pointerA = headA
        pointerB = headB
        
        # 遍历两个链表直到指针相交
        while pointerA != pointerB:
            # 将指针向前移动一个节点
            pointerA = pointerA.next if pointerA else headB
            pointerB = pointerB.next if pointerB else headA
        
        # 如果相交，指针将位于交点节点，如果没有交点，值为None
        return pointerA
```



### 1048 - 环形链表 II<a id="p1048"></a>

#### 问题

给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

**不允许修改** 链表。



 

**示例 1：**

![img](./assets/circularlinkedlist-1709788115895-15.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例 2：**

![img](./assets/circularlinkedlist_test2-1709788115896-17.png)

```
输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。
```

**示例 3：**

![img](./assets/circularlinkedlist_test3-1709788115896-19.png)

```
输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。
```



#### 解法

暴力解法：遍历一遍，将所有的结点加入哈希表，对比即可

```python
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # 暴力，使用哈希表
        hashset = set()
        while head:
            if head in hashset:
                return head
            else:
                hashset.add(head)
            head = head.next
        return None
```

快慢指针，经过数学推导：找到相遇结点之后，从起始结点和相遇结点各自发出一个指针，相遇后必定为环形入口。

```python
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # 快慢指针
        if not head:
            return None
        fast = slow = Prenode = ListNode(next = head)
        love_point = None
        while fast and fast.next and fast.next.next:
            if fast == slow and fast != Prenode:
                love_point = slow
                while Prenode != love_point:
                    Prenode = Prenode.next
                    love_point = love_point.next
                return love_point
            slow = slow.next
            fast = fast.next.next

        return None
```



### 1049 - 有效的字母异位词<a id="p1049"></a>

#### 问题

给定两个字符串 `*s*` 和 `*t*` ，编写一个函数来判断 `*t*` 是否是 `*s*` 的字母异位词。

**注意：**若 `*s*` 和 `*t*` 中每个字符出现的次数都相同，则称 `*s*` 和 `*t*` 互为字母异位词。

 

**示例 1:**

```
输入: s = "anagram", t = "nagaram"
输出: true
```

**示例 2:**

```
输入: s = "rat", t = "car"
输出: false
```



#### 解法

哈希表对比：即便键值对的位置不同但是仍然是一样的。

```python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        # 使用字典处理，即便是字典键值对位置不同依然是相等的
        dirt1, dirt2 = {}, {}
        for i in s:
            if i in dirt1:
                dirt1[i] = dirt1[i] + 1
            else:
                dirt1.setdefault(i, 1)

        for i in t:
            if i in dirt2:
                dirt2[i] = dirt2[i] + 1
            else:
                dirt2.setdefault(i, 1)

        return dirt1 == dirt2
```

使用`collections.defaultdict()` 类

```python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        from collections import defaultdict
        
        s_dict = defaultdict(int)
        t_dict = defaultdict(int)
        for x in s:
            s_dict[x] += 1
        
        for x in t:
            t_dict[x] += 1
        return s_dict == t_dict
```



### 1050 - 两个数组的交集<a id="p1050"></a>

#### 问题

给定两个数组 `nums1` 和 `nums2` ，返回 *它们的交集* 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。

 

**示例 1：**

```
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
```

**示例 2：**

```
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
解释：[4,9] 也是可通过的
```



#### 解法

普通暴力解法

```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        # 暴力
        new_set = set()
        for i in nums1:
            if i in nums2:
                new_set.add(i)
        return list(new_set)
```

集合直接取交集操作

```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        # set之间使用位运算符可以实现并集、交集的操作
        return list(set(nums1) & set(nums2))
```



### 1051 - 快乐数<a id="p1051"></a>

#### 问题

编写一个算法来判断一个数 `n` 是不是快乐数。

**「快乐数」** 定义为：

- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
- 如果这个过程 **结果为** 1，那么这个数就是快乐数。

如果 `n` 是 *快乐数* 就返回 `true` ；不是，则返回 `false` 。

 

**示例 1：**

```
输入：n = 19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
```

**示例 2：**

```
输入：n = 2
输出：false
```



#### 解法

```python
class Solution:
    def isHappy(self, n: int) -> bool:
        # 经过数学演算，如果是无限循环，也是有规律的循环：即还会回到最初值
        lst = [n]
        while True:
            next_num = 0
            if n == 1:
                return True
            for i in str(n):
                next_num += int(i) * int(i)
            n = next_num
            if next_num not in lst:
                lst.append(next_num)
            else:
                return False
```



### 1052 - 四数相加 II<a id="p1052"></a>

#### 问题

给你四个整数数组 `nums1`、`nums2`、`nums3` 和 `nums4` ，数组长度都是 `n` ，请你计算有多少个元组 `(i, j, k, l)` 能满足：

- `0 <= i, j, k, l < n`
- `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`

 

**示例 1：**

```
输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
输出：2
解释：
两个元组如下：
1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0
```

**示例 2：**

```
输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]
输出：1
```



#### 解法

分段处理，将A、B数组的和统计，和作为键，出现次数为值；以相同的方式遍历C、D，一旦发现和的负数存在于字典中就将对应的值累加到结果。

```python
class Solution:
    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:
        # 转换思路，先统计a + b的和出现的次数
        # 再统计c + d的和的次数
        # 将相减为0的次数相乘，累加
        dirt1, dirt2 = {}, {}
        result = 0
        for i in nums1:
            for j in nums2:
                temp = i + j
                if temp in dirt1:
                    dirt1[temp] += 1
                else:
                    dirt1[temp] = 1

        for k in nums3:
            for l in nums4:
                temp = -(k + l)
                if temp in dirt1:
                    result += dirt1[temp]

        return result
```



### 1053 - 赎金信<a id="p1053"></a>

#### 问题

给你两个字符串：`ransomNote` 和 `magazine` ，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。

如果可以，返回 `true` ；否则返回 `false` 。

`magazine` 中的每个字符只能在 `ransomNote` 中使用一次。

 

**示例 1：**

```
输入：ransomNote = "a", magazine = "b"
输出：false
```

**示例 2：**

```
输入：ransomNote = "aa", magazine = "ab"
输出：false
```

**示例 3：**

```
输入：ransomNote = "aa", magazine = "aab"
输出：true
```



#### 解法

将magazine出现的字符以及次数记录在字典中，遍历rensonNote中的字符，如果不存在就返回否，如果字典的值为0就删掉这个键值对。

```python
class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        records = dict()
        for i in magazine:
            records[i] = records.get(i, 0) + 1
        for i in ransomNote:
            if i not in records:
                return False
            records[i] = records.get(i, 0) - 1
            if records[i] == 0:
                records.pop(i)
        return True
```



### 1054 - 三数之和<a id="p1054"></a>

#### 问题

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请

你返回所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

 

 

**示例 1：**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
```

**示例 2：**

```
输入：nums = [0,1,1]
输出：[]
解释：唯一可能的三元组和不为 0 。
```

**示例 3：**

```
输入：nums = [0,0,0]
输出：[[0,0,0]]
解释：唯一可能的三元组和为 0 。
```



#### 解法

双指针

代码随想录：

![15.三数之和](./assets/15.三数之和.gif)

拿这个nums数组来举例，首先将数组排序，然后有一层for循环，i从下标0的地方开始，同时定一个下标left 定义在i+1的位置上，定义下标right 在数组结尾的位置上。

依然还是在数组中找到 abc 使得a + b +c =0，我们这里相当于 a = nums[i]，b = nums[left]，c = nums[right]。

接下来如何移动left 和right呢， 如果nums[i] + nums[left] + nums[right] > 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。

如果 nums[i] + nums[left] + nums[right] < 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        
        n=len(nums)
        res=[]
        if not nums:
            return []
        nums.sort()
        res=[]
        for i in range(n):
            if(nums[i]>0):
                return res
            if(i>0 and nums[i]==nums[i-1]):
                continue
            L=i+1
            R=n-1
            while(L<R):
                if(nums[i]+nums[L]+nums[R]==0):
                    res.append([nums[i],nums[L],nums[R]])
                    while(L<R and nums[L]==nums[L+1]):
                        L=L+1
                    while(L<R and nums[R]==nums[R-1]):
                        R=R-1
                    L=L+1
                    R=R-1
                elif(nums[i]+nums[L]+nums[R]>0):
                    R=R-1
                else:
                    L=L+1
        return res
```



### 1055 - 四数之和<a id="p1054"></a>

#### 问题

给你一个由 `n` 个整数组成的数组 `nums` ，和一个目标值 `target` 。请你找出并返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：

- `0 <= a, b, c, d < n`
- `a`、`b`、`c` 和 `d` **互不相同**
- `nums[a] + nums[b] + nums[c] + nums[d] == target`

你可以按 **任意顺序** 返回答案 。

 

**示例 1：**

```
输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
```

**示例 2：**

```
输入：nums = [2,2,2,2,2], target = 8
输出：[[2,2,2,2]]
```



#### 解法

双指针去重

与[1054 - 三数之和](#p1054)类似，叠了两层for循环；而且值得关注的是优化部分的代码:

```python
if x + nums[i + 1] + nums[i + 2] + nums[i + 3] > target:  # 优化一
    break
if x + nums[-3] + nums[-2] + nums[-1] < target:  # 优化二
    continue
```

这一部分的含义是：由于数组是被排序过的，所以当初始的最小元素和大于target，说明整体不需要再循环了，因为后续的值只会更大；而如果当前最大的值仍然比target小，就将指针向右移动。(这一部分三层和两层是一样的)

```python
class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        # 难点在于去重
        lenth = len(nums)
        nums.sort()
        ans = []
        for i in range(lenth - 3):
            x = nums[i]
            # 去重
            if i and nums[i] == nums[i - 1]:
                continue
            if x + nums[i + 1] + nums[i + 2] + nums[i + 3] > target:  # 优化一
                break
            if x + nums[-3] + nums[-2] + nums[-1] < target:  # 优化二
                continue
            for j in range(i + 1, lenth - 2):
                y = nums[j]
                if j > i + 1 and y == nums[j - 1]:  # 跳过重复数字
                    continue
                if x + y + nums[j + 1] + nums[j + 2] > target:  # 优化一
                    break
                if x + y + nums[-2] + nums[-1] < target:  # 优化二
                    continue
                c = j + 1
                d = lenth - 1
                while c < d:
                    s = x + y + nums[c] + nums[d]
                    if s > target:
                        d -= 1
                    elif s < target:
                        c += 1
                    else:
                        ans.append([x, y, nums[c], nums[d]])
                        c += 1
                        while c < d and nums[c] == nums[c - 1]:
                            c += 1
                        d -= 1
                        while d > c and nums[d] == nums[d + 1]:
                            d -= 1
        return ans
```

字典法

求出target和三个元素的差值，判断这个差值是否重复，

如何判断重复？只要目标值val和前面的三元素之一重复，就说明val可能重复了，但是`if freq[val] > count`可以判断是否真正的重复：如果它出现的频率大于可能重复的次数，就说明它一定不重复且存在。

如果不重复就将其加入最终结果。

```python
class Solution(object):
    def fourSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        # 创建一个字典来存储输入列表中每个数字的频率
        freq = {}
        for num in nums:
            freq[num] = freq.get(num, 0) + 1
        
        # 创建一个集合来存储最终答案，并遍历4个数字的所有唯一组合
        ans = set()
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                for k in range(j + 1, len(nums)):
                    val = target - (nums[i] + nums[j] + nums[k])
                    if val in freq:
                        # 确保没有重复
                        count = (nums[i] == val) + (nums[j] == val) + (nums[k] == val)
                        if freq[val] > count:
                            ans.add(tuple(sorted([nums[i], nums[j], nums[k], val])))
        
        return [list(x) for x in ans]
```



### 1056 - 反转字符串中的单词<a id="p1056"></a>

#### 问题

给你一个字符串 `s` ，请你反转字符串中 **单词** 的顺序。

**单词** 是由非空格字符组成的字符串。`s` 中使用至少一个空格将字符串中的 **单词** 分隔开。

返回 **单词** 顺序颠倒且 **单词** 之间用单个空格连接的结果字符串。

**注意：**输入字符串 `s`中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。

 

**示例 1：**

```
输入：s = "the sky is blue"
输出："blue is sky the"
```

**示例 2：**

```
输入：s = "  hello world  "
输出："world hello"
解释：反转后的字符串中不能存在前导空格和尾随空格。
```

**示例 3：**

```
输入：s = "a good   example"
输出："example good a"
解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。
```



#### 解法

调库

```python
return " ".join(s.split()[::-1])
```

双指针，切割后双向奔赴

```python
class Solution:
    def reverseWords(self, s: str) -> str:
        # 切割，双向奔赴反转
        lst = s.split()
        l, r = 0, len(lst) - 1
        while l < r:
            lst[l], lst[r] = lst[r], lst[l]
            l += 1
            r -= 1
        return " ".join(lst)
```



### 1057 - 重复的子字符串<a id="p1057"></a>

#### 问题

给定一个非空的字符串 `s` ，检查是否可以通过由它的一个子串重复多次构成。

 

**示例 1:**

```
输入: s = "abab"
输出: true
解释: 可由子串 "ab" 重复两次构成。
```

**示例 2:**

```
输入: s = "aba"
输出: false
```

**示例 3:**

```
输入: s = "abcabcabcabc"
输出: true
解释: 可由子串 "abc" 重复四次构成。 (或子串 "abcabc" 重复两次构成。)
```



#### 解法

代码随想录：移动匹配

当一个字符串s：abcabc，内部由重复的子串组成，那么这个字符串的结构一定是这样的：

![图一](./assets/20220728104518.png)

也就是由前后相同的子串组成。

那么既然前面有相同的子串，后面有相同的子串，用 s + s，这样组成的字符串中，后面的子串做前串，前面的子串做后串，就一定还能组成一个s，如图：

![图二](./assets/20220728104931.png)

所以判断字符串s是否由重复子串组成，只要两个s拼接在一起，里面还出现一个s的话，就说明是由重复子串组成。

当然，我们在判断 s + s 拼接的字符串里是否出现一个s的的时候，**要刨除 s + s 的首字符和尾字符**，这样避免在s+s中搜索出原来的s，我们要搜索的是中间拼接出来的s。



下面是使用in方法

```python
class Solution:
    def repeatedSubstringPattern(self, s: str) -> bool:
        n = len(s)
        if n <= 1:
            return False
        ss = s[1:] + s[:-1]             
        return s in ss
```

下面是使用find方法

```python
class Solution:
    def repeatedSubstringPattern(self, s: str) -> bool:
        n = len(s)
        if n <= 1:
            return False
        ss = s[1:] + s[:-1] 
        print(ss.find(s))              
        return ss.find(s) != -1
```



### 1058 - 删除字符串中的所有相邻重复项<a id="p1058"></a>

#### 问题

给出由小写字母组成的字符串 `S`，**重复项删除操作**会选择两个相邻且相同的字母，并删除它们。

在 S 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

 

**示例：**

```
输入："abbaca"
输出："ca"
解释：
例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。
```



#### 解法

使用栈

```python
class Solution:
    def removeDuplicates(self, s: str) -> str:
        result = []
        for i in s:
            if result and i == result[-1]:
                result.pop()
            else:
                result.append(i)
        return "".join(result)
```

使用双指针

```python
class Solution:
    def removeDuplicates(self, s: str) -> str:
        res = list(s)
        slow = fast = 0
        length = len(res)

        while fast < length:
            # 如果一样直接换，不一样会把后面的填在slow的位置
            res[slow] = res[fast]
            
            # 如果发现和前一个一样，就退一格指针
            if slow > 0 and res[slow] == res[slow - 1]:
                slow -= 1
            else:
                slow += 1
            fast += 1
            
        return ''.join(res[0: slow])
```



### 1059 - 逆波兰表达式求值<a id="p1059"></a>

#### 问题

给你一个字符串数组 `tokens` ，表示一个根据 [逆波兰表示法](https://baike.baidu.com/item/逆波兰式/128437) 表示的算术表达式。

请你计算该表达式。返回一个表示表达式值的整数。

**注意：**

- 有效的算符为 `'+'`、`'-'`、`'*'` 和 `'/'` 。
- 每个操作数（运算对象）都可以是一个整数或者另一个表达式。
- 两个整数之间的除法总是 **向零截断** 。
- 表达式中不含除零运算。
- 输入是一个根据逆波兰表示法表示的算术表达式。
- 答案及所有中间计算结果可以用 **32 位** 整数表示。

 

**示例 1：**

```
输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
```

**示例 2：**

```
输入：tokens = ["4","13","5","/","+"]
输出：6
解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
```

**示例 3：**

```
输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
输出：22
解释：该算式转化为常见的中缀算术表达式为：
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
```



#### 解法

**逆波兰表达式：**

逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。

- 平常使用的算式则是一种中缀表达式，如 `( 1 + 2 ) * ( 3 + 4 )` 。
- 该算式的逆波兰表达式写法为 `( ( 1 2 + ) ( 3 4 + ) * )` 。

逆波兰表达式主要有以下两个优点：

- 去掉括号后表达式无歧义，上式即便写成 `1 2 + 3 4 + * `也可以依据次序计算出正确结果。
- **适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中**

```python
class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        # 栈：遇到数字则入栈，遇到运算符则去除栈顶的两个数字进行计算，并将结果压入栈中
        lst = []
        for i in tokens:
            if i not in {"+", "-", "*", "/"}:
                lst.append(int(i))
            elif i == "+":
                a = lst.pop()
                b = lst.pop()
                lst.append(a + b)
            elif i == "-":
                a = lst.pop()
                b = lst.pop()
                lst.append(b - a)
            elif i == "*":
                a = lst.pop()
                b = lst.pop()
                lst.append(a * b)
            elif i == "/":
                a = lst.pop()
                b = lst.pop()
                lst.append(int(b / a))

        return lst[0]
```

使用字典后的简化版本

```python
from operator import add, sub, mul

class Solution:
    op_map = {'+': add, '-': sub, '*': mul, '/': lambda x, y: int(x / y)}
    
    def evalRPN(self, tokens: List[str]) -> int:
        stack = []
        for token in tokens:
            if token not in {'+', '-', '*', '/'}:
                stack.append(int(token))
            else:
                op2 = stack.pop()
                op1 = stack.pop()
                stack.append(self.op_map[token](op1, op2))  # 第一个出来的在运算符后面
        return stack.pop()
```



### 1060 - 滑动窗口的最大值<a id="p1060"></a>

#### 问题

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 *滑动窗口中的最大值* 。

 

**示例 1：**

```
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

**示例 2：**

```
输入：nums = [1], k = 1
输出：[1]
```



#### 解法

代码随想录

> 来看一下单调队列如何维护队列里的元素。
>
> 动画如下：
>
> ![239.滑动窗口最大值](./assets/239.滑动窗口最大值.gif)

> 对于窗口里的元素{2, 3, 5, 1 ,4}，单调队列里只维护{5, 4} 就够了，保持单调队列里单调递减，此时队列出口元素就是窗口里最大元素。
>
> 此时大家应该怀疑单调队列里维护着{5, 4} 怎么配合窗口进行滑动呢？
>
> 设计单调队列的时候，pop，和push操作要保持如下规则：
>
> 1. pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作
> 2. push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止
>
> 保持如上规则，每次窗口移动的时候，只要问que.front()就可以返回当前窗口的最大值。
>
> 为了更直观的感受到单调队列的工作过程，以题目示例为例，输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3，动画如下：

> ![239.滑动窗口最大值-2](./assets/239.滑动窗口最大值-2.gif)



目前最优解法，使用collection包下面的deque数据结构进行操作，具体实现是单调队列。

```python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        l=[]
        n=len(nums)
        deque=collections.deque()
        for i in range(k):
            while deque and nums[i]>deque[-1]:
                deque.pop()
            deque.append(nums[i])
        l.append(deque[0])
        for i in range(k,n):
            if deque[0]==nums[i-k]:
                deque.popleft()
            while deque and nums[i]>deque[-1]:
                deque.pop()
            deque.append(nums[i])
            l.append(deque[0])
        return l
```

正常人的暴力解法，LeetCode通过90%

```python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        if k == 1:
            return nums
        # 记录最大值的索引，最大索引以后方为主
        # 一旦索引越界就更新最大值并记录索引
        max_num = max(nums[0:k])
        max_index = 0
        for i in range(k):
            if nums[i] == max_num:
                max_index = i
        result = [max_num]

        for i in range(k, len(nums)):
            if i - k  + 1> max_index:
                max_num = max(nums[i - k + 1:i + 1])
                for j in range(i - k + 1, i + 1):
                    if nums[j] == max_num:
                        max_index = j
            elif nums[i] > max_num:
                max_num = nums[i]
            result.append(max_num)
        return result
```



### 1061 - 前k个高频元素<a id="p1061"></a>

#### 问题

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。

 

**示例 1:**

```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

**示例 2:**

```
输入: nums = [1], k = 1
输出: [1]
```



#### 解法

使用哈希表进行暴力解法，其中用到了字典的`zip()`方法：将字典的键和值反转。

```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        暴力
        result = []
        dirt = {}
        for i in nums:
            dirt[i] = dirt.get(i, 0) + 1
        for i in range(k):
            max_index = max(zip(dirt.values(), dirt.keys()))
            result.append(max_index[1])
            dirt.pop(result[-1])
        return result
```

使用列表代替小顶堆，也是暴力解法，不过速度要快很多。

```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        result = []
        lst = []
        dirt = {}
        for i in nums:
            dirt[i] = dirt.get(i, 0) + 1

        for key, value in dirt.items():
            lst.append((value, key))
        lst.sort()
        for i in range(len(lst) - 1, len(lst) - k - 1, -1):
            result.append(lst[i][-1])
        return result
```

使用headq模块，是对堆的相关操作的模块。

关于headq模块的使用可以参考[Python中heapq模块浅析_heapq.heappush-CSDN博客](https://blog.csdn.net/chandelierds/article/details/91357784)

代码随想录：

> ![347.前K个高频元素](./assets/347.前K个高频元素.jpg)

```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        #时间复杂度：O(nlogk)
        #空间复杂度：O(n)
        import heapq
        #要统计元素出现频率
        map_ = {} #nums[i]:对应出现的次数
        for i in range(len(nums)):
            map_[nums[i]] = map_.get(nums[i], 0) + 1
        
        #对频率排序
        #定义一个小顶堆，大小为k
        pri_que = [] #小顶堆
        
        #用固定大小为k的小顶堆，扫描所有频率的数值
        for key, freq in map_.items():
            heapq.heappush(pri_que, (freq, key))
            print(pri_que)
            if len(pri_que) > k: #如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k
                heapq.heappop(pri_que)
                print("弹出后", pri_que)
        

        print("最终的", pri_que)
        #找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组
        result = [0] * k
        for i in range(k-1, -1, -1):
            result[i] = heapq.heappop(pri_que)[1]
        return result
```



### 1062 - 二叉树的层序遍历<a id="p1062"></a>

#### 问题

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

 

**示例 1：**

![img](./assets/tree1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
```

**示例 2：**

```
输入：root = [1]
输出：[[1]]
```

**示例 3：**

```
输入：root = []
输出：[]
```



#### 解法

常规迭代

```python
if not root:
            return []
        stack = [root]
        result = []
        while stack:
            temp = []
            for _ in range(len(stack)):
                node = stack.pop(0)
                temp.append(node.val)
                if node.left:
                    stack.append(node.left)
                if node.right:
                    stack.append(node.right)
            result.append(temp)
        return result
```

使用collections模块中的deque数据结构，能优化速度

```python
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        # deque是一个增强列表，提供了双向增删改；该函数是将列表转为双向列表
        queue = collections.deque([root])
        result = []
        while queue:
            level = []
            for _ in range(len(queue)):
                # 取出头部元素
                cur = queue.popleft()
                level.append(cur.val)
                if cur.left:
                    queue.append(cur.left)
                if cur.right:
                    queue.append(cur.right)
            result.append(level)
        return result
```

实际上二者的原理是一样的，不过双端队列(deque)数据结构应该能优化底层的速度



### 1063 - 二叉树的右视图<a id="p1063"></a>

#### 问题

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

 

**示例 1:**

![img](./assets/tree.jpg)

```
输入: [1,2,3,null,5,null,4]
输出: [1,3,4]
```

**示例 2:**

```
输入: [1,null,3]
输出: [1,3]
```

**示例 3:**

```
输入: []
输出: []
```



#### 解法

只需要进行层序遍历即可，最后将每层的最后一个元素返回即可。

 ```python
 class Solution:
     def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
         from collections import deque
         if not root:
             return []
         deque = collections.deque([root])
         result = []
         while deque:
             lenth = len(deque)
             for i in range(lenth):
                 node = deque.popleft()
                 if i == lenth - 1:
                     result.append(node.val)
                 if node.left:
                     deque.append(node.left)
                 if node.right:
                     deque.append(node.right)
         return result
 ```



### 1064 - 二叉树的层平均值<a id="p1064"></a>

#### 问题

给定一个非空二叉树的根节点 `root` , 以数组的形式返回每一层节点的平均值。与实际答案相差 `10-5` 以内的答案可以被接受。

 

**示例 1：**

![img](./assets/avg1-tree.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：[3.00000,14.50000,11.00000]
解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。
因此返回 [3, 14.5, 11] 。
```

**示例 2:**

![img](./assets/avg2-tree.jpg)

```
输入：root = [3,9,20,15,7]
输出：[3.00000,14.50000,11.00000]
```



#### 解法

```python
class Solution:
    def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:
        from collections import deque
        deque = collections.deque([root])
        result = []
        while deque:
            temp = []
            for _ in range(len(deque)):
                node = deque.popleft()
                temp.append(node.val)
                if node.left:
                    deque.append(node.left)
                if node.right:
                    deque.append(node.right)
            result.append(sum(temp) / len(temp))
        return result
```



### 1065 - N叉树的层序遍历<a id="p1065"></a>

#### 问题

给定一个 N 叉树，返回其节点值的*层序遍历*。（即从左到右，逐层遍历）。

树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。

 

**示例 1：**

![img](./assets/narytreeexample.png)

```
输入：root = [1,null,3,2,4,null,5,6]
输出：[[1],[3,2,4],[5,6]]
```

**示例 2：**

![img](./assets/sample_4_964.png)

```
输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]
```



#### 解法

常规运用模板

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
"""

class Solution:
    def levelOrder(self, root: 'Node') -> List[List[int]]:
        if not root:
            return []
        from collections import deque
        deque = collections.deque([root])
        result = []
        while deque:
            temp = []
            for i in range(len(deque)):
                node = deque.popleft()
                temp.append(node.val)
                for j in node.children:
                    deque.append(j)
            result.append(temp)
        return result
```



### 1066 - 在每个树行中找最大值<a id="p1066"></a>

#### 问题

给定一棵二叉树的根节点 `root` ，请找出该二叉树中每一层的最大值。

 

**示例1：**

![img](./assets/largest_e1.jpg)

```
输入: root = [1,3,2,5,3,null,9]
输出: [1,3,9]
```

**示例2：**

```
输入: root = [1,2,3]
输出: [1,3]
```



#### 解法

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def largestValues(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []
        deque = collections.deque([root])
        result = []
        while deque:
            max_num = float('-inf')
            for _ in range(len(deque)):
                node = deque.popleft()
                max_num = node.val if node.val > max_num else max_num
                if node.left:
                    deque.append(node.left)
                if node.right:
                    deque.append(node.right)
            result.append(max_num)
        return result
```



### 1067 - 填充每个节点的下一个右侧节点指针<a id="p1067"></a>

#### 问题

给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。

初始状态下，所有 next 指针都被设置为 `NULL`。

 

**示例 1：**

![img](./assets/116_sample.png)

```
输入：root = [1,2,3,4,5,6,7]
输出：[1,#,2,3,#,4,5,6,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。
```



**示例 2:**

```
输入：root = []
输出：[]
```



#### 解法

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
"""
class Solution:
    def connect(self, root: 'Optional[Node]') -> 'Optional[Node]':
        if not root:
            return None
        from collections import deque
        deque = collections.deque([root])
        result = []
        while deque:
            temp = []
            for _ in range(len(deque)):
                node = deque.popleft()
                temp.append(node)
                if node.left:
                    deque.append(node.left)
                if node.right:
                    deque.append(node.right)
            result.append(temp)
        for lst in result:
            for i in range(len(lst) - 1):
                lst[i].next = lst[i + 1]
        return root
```



### 1068 - 填充每个节点的下一个右侧节点指针 II<a id="p1068"></a>

#### 问题

给定一个二叉树：

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL` 。

初始状态下，所有 next 指针都被设置为 `NULL` 。

 

**示例 1：**

![img](./assets/117_sample.png)

```
输入：root = [1,2,3,4,5,null,7]
输出：[1,#,2,3,#,4,5,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），'#' 表示每层的末尾。
```

**示例 2：**

```
输入：root = []
输出：[]
```



#### 解法

与上一题一致



### 1069 - 翻转二叉树<a id="p1069"></a>

#### 问题

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

 

**示例 1：**

![img](./assets/invert1-tree.jpg)

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

**示例 2：**

![img](./assets/invert2-tree.jpg)

```
输入：root = [2,1,3]
输出：[2,3,1]
```

**示例 3：**

```
输入：root = []
输出：[]
```



#### 解法

递归

```python
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return root
        self.invertTree(root.left)
        self.invertTree(root.right)
        root.left, root.right = root.right, root.left
        return root
```

迭代，貌似没有递归快

```python
class Solution:
    def reverse(self, root):
        if not root:
            return None
        from collections import deque
        deque = collections.deque([root])
        while deque:
            for _ in range(len(deque)):
                node = deque.popleft()
                node.right, node.left = node.left, node.right
                if node.left:
                    deque.append(node.left)
                if node.right:
                    deque.append(node.right)
        return root
```



### 1070 - 完全二叉树的节点个数<a id="p1070"></a>

#### 问题

给你一棵 **完全二叉树** 的根节点 `root` ，求出该树的节点个数。

[完全二叉树](https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin) 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 `h` 层，则该层包含 `1~ 2h` 个节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/14/complete.jpg)

```
输入：root = [1,2,3,4,5,6]
输出：6
```

**示例 2：**

```
输入：root = []
输出：0
```

**示例 3：**

```
输入：root = [1]
输出：1
```



#### 解法

迭代计算节点数量

```python
class Solution:
    def countNodes(self, root: Optional[TreeNode]) -> int:
        from collections import deque
        lst = collections.deque()
        if root:
            lst.append(root)
        result = 0
        while lst:
            lenth = len(lst)
            for _ in range(lenth):
                node = lst.popleft()
                result += 1
                if node.left:
                    lst.append(node.left)
                if node.right:
                    lst.append(node.right)
        return result
```

递归计算节点数量

```python
class Solution:
    def countNodes(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        return 1 + self.countNodes(root.left) + self.countNodes(root.right)
```



### 1071 - 二叉树的所有路径<a id="p1071"></a>

#### 问题

给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。

**叶子节点** 是指没有子节点的节点。

 

**示例 1：**

![img](./assets/paths-tree.jpg)

```
输入：root = [1,2,3,null,5]
输出：["1->2->5","1->3"]
```

**示例 2：**

```
输入：root = [1]
输出：["1"]
```



#### 解法

递归 + 隐形回溯

```python
# 隐形回溯
class Solution:
    def binaryTreePaths(self, root: TreeNode) -> List[str]:
        result = []
        if not root: return result
        self.traversal(root, '', result)
        return result
    
    def traversal(self, cur: TreeNode, path: str, result: List[str]) -> None:
        path += str(cur.val)
        # 若当前节点为leave，直接输出
        if not cur.left and not cur.right:
            result.append(path)
            return

        if cur.left:
            # + '->' 是隐藏回溯
            self.traversal(cur.left, path + '->', result)
        
        if cur.right:
            self.traversal(cur.right, path + '->', result)
```



### 1072 - 左叶子之和<a id="p1072"></a>

#### 解法

给定二叉树的根节点 `root` ，返回所有左叶子之和。

 

**示例 1：**

![img](./assets/leftsum-tree.jpg)

```
输入: root = [3,9,20,null,null,15,7] 
输出: 24 
解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
```

**示例 2:**

```
输入: root = [1]
输出: 0
```



#### 问题

模板迭代

```python
class Solution:
    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:
        if not root.left and not root.right:
            return 0
        from collections import deque
        deque = collections.deque([root])
        result = 0
        while deque:
            for _ in range(len(deque)):
                node = deque.popleft()
                if node.left and not node.left.left and not node.left.right:
                    result += node.left.val
                elif node.left:
                    deque.append(node.left)
                if node.right:
                    deque.append(node.right)
        return result
```

递归

```python
class Solution:
    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:
        if root is None:
            return 0
        leftValue = 0
        if root.left is not None and root.left.left is None and root.left.right is None:
            leftValue = root.left.val
        return leftValue + self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)
```



### 1073 - 找树左下角的值<a id="p1073"></a>

#### 问题

给定一个二叉树的 **根节点** `root`，请找出该二叉树的 **最底层 最左边** 节点的值。

假设二叉树中至少有一个节点。

 

**示例 1:**

![img](./assets/tree1-1710237223920-1.jpg)

```
输入: root = [2,1,3]
输出: 1
```

**示例 2:**

![img](./assets/tree2.jpg)

```
输入: [1,2,3,4,null,5,6,null,null,7]
输出: 7
```



#### 解法

迭代法

```python
class Solution:
    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:
        from collections import deque
        deque = collections.deque([root])
        result = []
        while deque:
            temp = []
            for _ in range(len(deque)):
                node = deque.popleft()
                temp.append(node.val)
                if node.left:
                    deque.append(node.left)
                if node.right:
                    deque.append(node.right)
            result = temp
        return result[0]
```

递归

```python
class Solution:
    def findBottomLeftValue(self, root: TreeNode) -> int:
        self.max_depth = float('-inf')
        self.result = None
        self.traversal(root, 0)
        return self.result
    
    def traversal(self, node, depth):
        if not node.left and not node.right:
            if depth > self.max_depth:
                self.max_depth = depth
                self.result = node.val
            return
        
        # 这里注意先遍历左边是因为左侧会将最大值设置为自己的深度，这样就不会更改为右侧的节点的值
        if node.left:
            self.traversal(node.left, depth + 1) 
        if node.right:
            self.traversal(node.right, depth + 1)
```



### 1074 - 路径总和 II<a id="p1074"></a>

#### 问题

给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。

**叶子节点** 是指没有子节点的节点。

 

**示例 1：**

![img](./assets/pathsumii1.jpg)

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：[[5,4,11,2],[5,8,4,5]]
```

**示例 2：**

![img](./assets/pathsum2-1710242623525-7.jpg)

```
输入：root = [1,2,3], targetSum = 5
输出：[]
```

**示例 3：**

```
输入：root = [1,2], targetSum = 0
输出：[]
```

 

#### 解法

递归

```python
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        def find(node, targetsum, temp):
            print(targetsum)
            temp.append(node.val)
            if not node.left and not node.right and targetsum == 0:
                result.append(temp)
                return
            if node.left:
                find(node.left, targetsum - node.left.val, temp.copy())
            if node.right:
                find(node.right, targetsum - node.right.val, temp.copy())

        if not root:
            return []
        result = []
        find(root, targetSum - root.val, [])
        return result
```



### 1075 - 从中序与后序遍历序列构造二叉树<a id="p1075"></a>

#### 问题

给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 *二叉树* 。

 

**示例 1:**

![img](./assets/tree-1710245633746-11.jpg)

```
输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
输出：[3,9,20,null,null,15,7]
```

**示例 2:**

```
输入：inorder = [-1], postorder = [-1]
输出：[-1]
```

 

#### 解法

```python
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        # 后序遍历最后一个节点即为根节点
        # 中序遍历可以确定根节点的左侧节点和右侧节点
        # 递归
        if not postorder:
            return None
        root = TreeNode(postorder[-1])
        root_index = inorder.index(postorder[-1])
        midleft = inorder[:root_index]
        midright = inorder[root_index + 1:]
        backleft = postorder[:len(midleft)]
        backright = postorder[len(midleft):len(postorder) - 1]
        root.left = self.buildTree(midleft, backleft)
        root.right = self.buildTree(midright, backright)
        return root
```



### 1076 - 最大二叉树<a id="p1076"></a>

#### 问题

给定一个不重复的整数数组 `nums` 。 **最大二叉树** 可以用下面的算法从 `nums` 递归地构建:

1. 创建一个根节点，其值为 `nums` 中的最大值。
2. 递归地在最大值 **左边** 的 **子数组前缀上** 构建左子树。
3. 递归地在最大值 **右边** 的 **子数组后缀上** 构建右子树。

返回 *`nums` 构建的* ***最大二叉树\*** 。

 

**示例 1：**

![img](./assets/tree1-1710246539214-14.jpg)

```
输入：nums = [3,2,1,6,0,5]
输出：[6,3,5,null,2,0,null,null,1]
解释：递归调用如下所示：
- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。
    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。
        - 空数组，无子节点。
        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。
            - 空数组，无子节点。
            - 只有一个元素，所以子节点是一个值为 1 的节点。
    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。
        - 只有一个元素，所以子节点是一个值为 0 的节点。
        - 空数组，无子节点。
```

**示例 2：**

![img](./assets/tree2-1710246539215-15.jpg)

```
输入：nums = [3,2,1]
输出：[3,null,2,null,1]
```

 

#### 解法

思路类似上题

```python
class Solution:
    def constructMaximumBinaryTree(self, nums: List[int]) -> Optional[TreeNode]:
        # 处理空列表
        if not nums:
            return None
        
        max_num = max(nums)
        root = TreeNode(max_num)

        # 找到切割点
        index = nums.index(max_num)
        
        # 切割左右子树
        lst_l = nums[:index]
        lst_r = nums[index + 1:]

        # 递归创建左右子树
        root.left = self.constructMaximumBinaryTree(lst_l)
        root.right = self.constructMaximumBinaryTree(lst_r)

        return root
```



### 1077 - 合并二叉树<a id="p1077"></a>

#### 问题

给你两棵二叉树： `root1` 和 `root2` 。

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，**不为** null 的节点将直接作为新二叉树的节点。

返回合并后的二叉树。

**注意:** 合并过程必须从两个树的根节点开始。

 

**示例 1：**

![img](./assets/merge.jpg)

```
输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
输出：[3,4,5,5,4,null,7]
```

**示例 2：**

```
输入：root1 = [1], root2 = [1,2]
输出：[2,2]
```

 

#### 解法

递归，思路与上面一样，称之为模板。

```python
class Solution:
    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root1 and not root2:
            return None
        if not root1 and root2:
            return root2
        if not root2 and root1:
            return root1
        
        root = TreeNode(root1.val + root2.val)

        root.left = self.mergeTrees(root1.left, root2.left)
        root.right = self.mergeTrees(root1.right, root2.right)

        return root
```

直接在root1上做修改，速度和空间应该更快且更小。

```python
class Solution:
    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:
        # 递归终止条件: 
        #  但凡有一个节点为空, 就立刻返回另外一个. 如果另外一个也为None就直接返回None. 
        if not root1: 
            return root2
        if not root2: 
            return root1
        # 上面的递归终止条件保证了代码执行到这里root1, root2都非空. 
        root1.val += root2.val # 中
        root1.left = self.mergeTrees(root1.left, root2.left) #左
        root1.right = self.mergeTrees(root1.right, root2.right) # 右
        
        return root1 # ⚠️ 注意: 本题我们重复使用了题目给出的节点而不是创建新节点. 节省时间, 空间.
```



### 1078 - 二叉搜索树中的搜索<a id="p1078"></a>

#### 问题

给定二叉搜索树（BST）的根节点 `root` 和一个整数值 `val`。

你需要在 BST 中找到节点值等于 `val` 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 `null` 。

 

**示例 1:**

![img](./assets/tree1-1710248503422-31.jpg)

```
输入：root = [4,2,7,1,3], val = 2
输出：[2,1,3]
```

**示例 2:**

![img](./assets/tree2-1710248488534-28.jpg)

```
输入：root = [4,2,7,1,3], val = 5
输出：[]
```

 

#### 解法

递归

```python
class Solution:
    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        if root.val == val:
            return root
        if (not root.left and not root.right) or (root.val > val and not root.left) or (root.val < val and not root.right):
            return None
        if root.val > val:
            return self.searchBST(root.left, val)
        elif root.val < val:
            return self.searchBST(root.right, val)
```

迭代

```python
class Solution:
    def searchBST(self, root: TreeNode, val: int) -> TreeNode:
        while root:
            if val < root.val: root = root.left
            elif val > root.val: root = root.right
            else: return root
        return None
```



### 1079 - 验证二叉搜索树<a id="p1079"></a>

#### 问题

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左

  子树

  只包含

   小于 

  当前节点的数。

- 节点的右子树只包含 **大于** 当前节点的数。

- 所有左子树和右子树自身必须也是二叉搜索树。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg)

```
输入：root = [2,1,3]
输出：true
```

**示例 2：**

![img](./assets/tree2-1710250890821-35.jpg)

```
输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值是 5 ，但是右子节点的值是 4 。
```



#### 解法

根据二叉搜索树的性质：一颗真正的二叉树转换为数组后，其数组是递增的，而且二叉搜索树不能有重复的值。

依据以上性质，使用迭代方法将搜索树转换为数组，验证数组是否重复且递增即可。

```python
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        # 中序遍历
        lst = [root]
        result = []
        while lst:
            node = lst.pop()
            if node:
                if node.right:
                    lst.append(node.right)
                lst.append(node)
                lst.append(None)
                if node.left:
                    lst.append(node.left)
                
            else:
                node = lst.pop()
                result.append(node.val)
        for i in range(1, len(result)):
            # 注意要小于等于，搜索树里不能有相同元素
            if result[i] <= result[i - 1]:
                return False
        return True
```

也可以根据搜索二叉树的性质进行暴力求解，即遍历树的每个节点。

```python
class Solution:
    def __init__(self):
        self.pre = None  # 用来记录前一个节点

    def isValidBST(self, root):
        if root is None:
            return True

        left = self.isValidBST(root.left)

        if self.pre is not None and self.pre.val >= root.val:
            return False
        self.pre = root  # 记录前一个节点

        right = self.isValidBST(root.right)
        return left and right

```

也可以使用迭代进行暴力对比，理论上是最优的方法。

```python
class Solution:
    def isValidBST(self, root):
        stack = []
        cur = root
        pre = None  # 记录前一个节点
        while cur is not None or len(stack) > 0:
            if cur is not None:
                stack.append(cur)
                cur = cur.left  # 左
            else:
                cur = stack.pop()  # 中
                if pre is not None and cur.val <= pre.val:
                    return False
                pre = cur  # 保存前一个访问的结点
                cur = cur.right  # 右
        return True
```



### 1080 - 二叉搜索树的最小绝对差<a id="p1080"></a>

#### 问题

给你一个二叉搜索树的根节点 `root` ，返回 **树中任意两不同节点值之间的最小差值** 。

差值是一个正数，其数值等于两值之差的绝对值。

 

**示例 1：**

![img](./assets/bst1.jpg)

```
输入：root = [4,2,6,1,3]
输出：1
```

**示例 2：**

![img](./assets/bst2.jpg)

```
输入：root = [1,0,48,null,null,12,49]
输出：1
```

 

#### 解法

迭代中序遍历二叉树的节点，记录最小差值即可。

```python
class Solution:
    def getMinimumDifference(self, root: Optional[TreeNode]) -> int:
        # 迭代中序遍历二叉树
        import collections
        from collections import deque
        deque = collections.deque([root])
        result = []
        while deque:
            node = deque.pop()
            if node:
                if node.right:
                    deque.append(node.right)
                deque.append(node)
                deque.append(None)
                if node.left:
                    deque.append(node.left)
            else:
                node = deque.pop()
                result.append(node.val)
        min_result = float('inf')
        for i in range(1, len(result)):
            min_result = min(result[i] - result[i - 1], min_result)
        return min_result
```

利用二叉搜索树的性质，一个节点的最小绝对差值，必定来源于其本身与左子树中的最大值或与右子树的最小值的差值。

以下利用了递归的方法对于差值。

```python
class Solution:
    # 寻找最大值和最小值
    # 将左侧最大值和右侧最小值返回

    # 使用时要注意传递该节点的左节点
    def getmax(self, root):
        if root.right:
            return self.getmax(root.right)
        else:
            return root.val

    def getmin(self, root):
        if root.left:
            return self.getmin(root.left)
        else:
            return root.val
    def getMinimumDifference(self, root: Optional[TreeNode]) -> int:
        if root.left and root.right:
            diff_l = min(root.val - self.getmax(root.left), self.getMinimumDifference(root.left))
            diff_r = min(self.getmin(root.right) - root.val, self.getMinimumDifference(root.right))
            return min(diff_l, diff_r)
        if root.left:
            return min(root.val - self.getmax(root.left), self.getMinimumDifference(root.left))
        if root.right:
            return min(self.getmin(root.right) - root.val, self.getMinimumDifference(root.right))
        if not root.left and not root.right:
            return float('inf')
```



### 1081 - 二叉搜索树中的众数<a id="p1081"></a>

#### 问题

给你一个含重复值的二叉搜索树（BST）的根节点 `root` ，找出并返回 BST 中的所有 [众数](https://baike.baidu.com/item/众数/44796)（即，出现频率最高的元素）。

如果树中有不止一个众数，可以按 **任意顺序** 返回。

假定 BST 满足如下定义：

- 结点左子树中所含节点的值 **小于等于** 当前节点的值
- 结点右子树中所含节点的值 **大于等于** 当前节点的值
- 左子树和右子树都是二叉搜索树

 

**示例 1：**

![img](./assets/mode-tree.jpg)

```
输入：root = [1,null,2,2]
输出：[2]
```

**示例 2：**

```
输入：root = [0]
输出：[0] 
```



#### 解法

记录搜索树中的所有节点，将所有节点的值以及出现频次加入哈希表即可。

```python
class Solution:
    def findMode(self, root: Optional[TreeNode]) -> List[int]:
        # 元组记录出现频次
        import collections
        from collections import deque
        deque = collections.deque([root])
        dirt = {}
        while deque:
            node = deque.pop()
            if node:
                if node.right:
                    deque.append(node.right)
                deque.append(node)
                deque.append(None)
                if node.left:
                    deque.append(node.left)
            else:
                node = deque.pop()
                dirt[node.val] = dirt.get(node.val, 0) + 1
        max_num = 0
        for i in dirt.values():
            max_num = max(i, max_num)
        result = []
        for key, value in dirt.items():
            if value == max_num:
                result.append(key)
        return result
```

使用collections模块中的defaultdict模块

```python
from collections import defaultdict

class Solution:
    def searchBST(self, cur, freq_map):
        if cur is None:
            return
        freq_map[cur.val] += 1  # 统计元素频率
        self.searchBST(cur.left, freq_map)
        self.searchBST(cur.right, freq_map)

    def findMode(self, root):
        freq_map = defaultdict(int)  # key:元素，value:出现频率
        result = []
        if root is None:
            return result
        self.searchBST(root, freq_map)
        max_freq = max(freq_map.values())
        for key, freq in freq_map.items():
            if freq == max_freq:
                result.append(key)
        return result
```

使用递归的方法，先一路向左，记录上一个节点与出现频率，一旦最大频率被更新，则清空结果数组，重新添加结果。重点在于其回溯思想。

```python
class Solution:
    def __init__(self):
        self.maxCount = 0  # 最大频率
        self.count = 0  # 统计频率
        self.pre = None
        self.result = []

    def searchBST(self, cur):
        if cur is None:
            return

        self.searchBST(cur.left)  # 左
        # 中
        if self.pre is None:  # 第一个节点
            self.count = 1
        elif self.pre.val == cur.val:  # 与前一个节点数值相同
            self.count += 1
        else:  # 与前一个节点数值不同
            self.count = 1
        self.pre = cur  # 更新上一个节点

        if self.count == self.maxCount:  # 如果与最大值频率相同，放进result中
            self.result.append(cur.val)

        if self.count > self.maxCount:  # 如果计数大于最大值频率
            self.maxCount = self.count  # 更新最大频率
            self.result = [cur.val]  # 很关键的一步，不要忘记清空result，之前result里的元素都失效了

        self.searchBST(cur.right)  # 右
        return

    def findMode(self, root):
        self.count = 0
        self.maxCount = 0
        self.pre = None  # 记录前一个节点
        self.result = []

        self.searchBST(root)
        return self.result
```



### 1082 - 二叉树的最近公共祖先<a id="p1082"></a>

#### 问题

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

 

**示例 1：**

![img](./assets/binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

**示例 2：**

![img](./assets/binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
```

**示例 3：**

```
输入：root = [1,2], p = 1, q = 2
输出：1
```

 

#### 解法

递归解法

```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        # 只是寻找p， q；其余节点一律当成空节点
        
        # 因为目标节点必定存在，所以如果头节点就是目标节点之一，直接返回头节点即可
        # 还有就是本判断条件置于头部就是为了处理目标节点是自己的公共祖先节点的情况
        if root == p or root == q or not root:
            return root
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p , q)
        # 处理目标节点左右分配在祖先节点左右
        if left and right:
            return root
        # 处理空节点
        if not left and not right:
            return None
        # 缩进后：因为空节点被处理了，剩下的情况就是存在一个目标节点
        return left if left else right
```



### 1083 - 二叉搜索树的最近公共祖先<a id="p1083"></a>

#### 问题

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]

![img](./assets/binarysearchtree_improved.png)

 

**示例 1:**

```
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。
```

**示例 2:**

```
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
```



#### 解法

不论是迭代还是递归，运用的都是二叉搜索树自带的排序属性，一定要分析好递归的条件和返回值，使其连贯。

迭代的方法：

```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        # 迭代
        while root:
            if root.val > p.val and root.val > q.val:
                root = root.left
            elif root.val < p.val and root.val < q.val:
                root = root.right
            else:
                return root
```

递归的方法：

```python
# 递归
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if root.val > p.val and root.val > q.val:
            return self.lowestCommonAncestor(root.left, p ,q)
        elif root.val < p.val and root.val < q.val:
            return self.lowestCommonAncestor(root.right, p ,q)
        else:
            return root
```



### 1084 - 二叉搜索树中的插入操作<a id="p1084"></a>

#### 问题

给定二叉搜索树（BST）的根节点 `root` 和要插入树中的值 `value` ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 **保证** ，新值和原始二叉搜索树中的任意节点值都不同。

**注意**，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 **任意有效的结果** 。

 

**示例 1：**

![img](./assets/insertbst-1710331209864-7.jpg)

```
输入：root = [4,2,7,1,3], val = 5
输出：[4,2,7,1,3,5]
解释：另一个满足题目要求可以通过的树是：
```

**示例 2：**

```
输入：root = [40,20,60,10,30,50,70], val = 25
输出：[40,20,60,10,30,50,70,null,null,25]
```

**示例 3：**

```
输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5
输出：[4,2,7,1,3,5]
```



#### 解法

通过迭代找到要插入的节点。

```python
class Solution:
    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        if not root:
            return TreeNode(val)
        result = root
        while True:
            if root.val > val and root.left:
                root = root.left
                continue
            elif root.val < val and root.right:
                root = root.right
                continue
            if root.val > val:
                root.left = TreeNode(val)
                return result
            else:
                root.right = TreeNode(val)
                return result
```



### 1085 - 删除二叉搜索树中的节点<a id="p1085"></a>

#### 问题

给定一个二叉搜索树的根节点 **root** 和一个值 **key**，删除二叉搜索树中的 **key** 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

一般来说，删除节点可分为两个步骤：

1. 首先找到需要删除的节点；
2. 如果找到了，删除它。

 

**示例 1:**

![img](./assets/del_node_1.jpg)

```
输入：root = [5,3,6,2,4,null,7], key = 3
输出：[5,4,6,2,null,null,7]
解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。
一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。
另一个正确答案是 [5,2,6,null,4,null,7]。
```

**示例 2:**

```
输入: root = [5,3,6,2,4,null,7], key = 0
输出: [5,3,6,2,4,null,7]
解释: 二叉树不包含值为 0 的节点
```

**示例 3:**

```
输入: root = [], key = 0
输出: []
```

 

#### 解法

```python
class Solution:
    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:
        # 递归
        if not root:
            return root
        if root.val == key:
            if not root.left and not root.right:
                return None
            elif not root.left:
                return root.right
            elif not root.right:
                return root.left
            else:
                node = root.right
                while node.left:
                    node = node.left
                node.left = root.left
                return root.right
        if root.val > key:
            root.left = self.deleteNode(root.left, key)
        if root.val < key:
            root.right = self.deleteNode(root.right, key)
        return root
```



### 1086 - 修建二叉搜索树<a id="p1086"></a>

#### 问题

给你二叉搜索树的根节点 `root` ，同时给定最小边界`low` 和最大边界 `high`。通过修剪二叉搜索树，使得所有节点的值在`[low, high]`中。修剪树 **不应该** 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 **唯一的答案** 。

所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。

 

**示例 1：**

![img](./assets/trim1.jpg)

```
输入：root = [1,0,2], low = 1, high = 2
输出：[1,null,2]
```

**示例 2：**

![img](./assets/trim2.jpg)

```
输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3
输出：[3,2,null,1]
```

 

#### 解法

```python
class Solution:
    def trimBST(self, root: Optional[TreeNode], low: int, high: int) -> Optional[TreeNode]:
        # 递归
        if root is None:
            return None
        if root.val < low:
            # 寻找符合区间 [low, high] 的节点
            return self.trimBST(root.right, low, high)
        if root.val > high:
            # 寻找符合区间 [low, high] 的节点
            return self.trimBST(root.left, low, high)
        root.left = self.trimBST(root.left, low, high)  # root.left 接入符合条件的左孩子
        root.right = self.trimBST(root.right, low, high)  # root.right 接入符合条件的右孩子
        return root
```



### 1087 - 把二叉搜索树转换为累加树<a id="p1087"></a>

#### 问题

给出二叉 **搜索** 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 `node` 的新值等于原树中大于或等于 `node.val` 的值之和。

提醒一下，二叉搜索树满足下列约束条件：

- 节点的左子树仅包含键 **小于** 节点键的节点。
- 节点的右子树仅包含键 **大于** 节点键的节点。
- 左右子树也必须是二叉搜索树。

**注意：**本题和 1038: https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/ 相同

 

**示例 1：**

**![img](./assets/tree.png)**

```
输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
```

**示例 2：**

```
输入：root = [0,null,1]
输出：[1,null,1]
```

**示例 3：**

```
输入：root = [1,0,2]
输出：[3,3,2]
```

**示例 4：**

```
输入：root = [3,2,4,1]
输出：[7,9,4,10]
```

 

#### 解法

通过中序遍历记录所有的节点，在对于每个节点进行累加即可。

```python
class Solution:
    def convertBST(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        # 中序遍历
        if not root:
            return root
        import collections
        from collections import deque
        deque = collections.deque([root])
        result = []
        while deque:
            node = deque.pop()
            if node:
                if node.right:
                    deque.append(node.right)
                deque.append(node)
                deque.append(None)
                if node.left:
                    deque.append(node.left)
            else:
                node = deque.pop()
                result.append(node)
        temp = 0
        for i in result[::-1]:
            i.val += temp
            temp = i.val
        return root
```

简化后，不需要记录节点。

```python
class Solution:
    def convertBST(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        # 中序遍历
        if not root:
            return root
        import collections
        from collections import deque
        deque = collections.deque()
        node = root
        pre = 0
        while deque or node:
            if node:
                deque.append(node)
                node = node.right
            else:
                node = deque.pop()
                node.val += pre
                pre = node.val
                node = node.left
        return root
```



### 3001 - 替换数字<a id="p3001"></a>

#### 问题

###### 题目描述

给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。 例如，对于输入字符串 "a1b2c3"，函数应该将其转换为 "anumberbnumbercnumber"。

###### 输入描述

输入一个字符串 s,s 仅包含小写字母和数字字符。

###### 输出描述

打印一个新的字符串，其中每个数字字符都被替换为了number

###### 输入示例

```
a1b2c3
```

###### 输出示例

```
anumberbnumbercnumber
```



#### 方法

字符串切割成，如果是数字就替换成number

```python
s = input()
result = ""
lst = []
for i in s:
    if ord(i) >= 48 and ord(i) <= 57:
        lst.append("number")
        continue
    lst.append(i)
    
for i in lst:
    result = result + i
    
print(result)
```



### 3002 -  右旋字符串<a id="p3002"></a>

#### 问题

###### 题目描述

字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。 

例如，对于输入字符串 "abcdefg" 和整数 2，函数应该将其转换为 "fgabcde"。

###### 输入描述

输入共包含两行，第一行为一个正整数 k，代表右旋转的位数。第二行为字符串 s，代表需要旋转的字符串。

###### 输出描述

输出共一行，为进行了右旋转操作后的字符串。

###### 输入示例

```
2
abcdefg
```

###### 输出示例

```
fgabcde
```



#### 解法

```python
# 所谓右旋字符串，就是按照先后顺序将一定位数的字符串反转到字符串左侧
k = int(input())
s = input()
lenth = len(s)
for i in range(-1,-(k + 1),-1):
    print(s[i])
    s = s[i] + s
print(s[:lenth])
```



### 1088 - 二叉搜索树中的插入操作<a id="p1088"></a>

#### 问题

给定二叉搜索树（BST）的根节点 `root` 和要插入树中的值 `value` ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 **保证** ，新值和原始二叉搜索树中的任意节点值都不同。

**注意**，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 **任意有效的结果** 。

 

**示例 1：**

![img](./assets/insertbst.jpg)

```
输入：root = [4,2,7,1,3], val = 5
输出：[4,2,7,1,3,5]
解释：另一个满足题目要求可以通过的树是：
```

**示例 2：**

```
输入：root = [40,20,60,10,30,50,70], val = 25
输出：[40,20,60,10,30,50,70,null,null,25]
```

**示例 3：**

```
输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5
输出：[4,2,7,1,3,5]
```



#### 解法

通过迭代最为简单

```python
# 迭代
class Solution:
    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:

        if not root:
            return TreeNode(val)
        result = root
        while True:
            if root.val > val and root.left:
                root = root.left
                continue
            elif root.val < val and root.right:
                root = root.right
                continue
            if root.val > val:
                root.left = TreeNode(val)
                return result
            else:
                root.right = TreeNode(val)
                return result
```



### 1089 - 组合<a id="p1089"></a>

#### 问题

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

 

**示例 1：**

```
输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

**示例 2：**

```
输入：n = 1, k = 1
输出：[[1]]
```

 

#### 解法

参考:[代码随想录](https://www.programmercarl.com/0077.组合.html)

记住回溯的模板，回溯本身就是递归。

 利用图片便于理解：

> ![77.组合3](./assets/20201123195407907.png)

对于本题而言，递归终止的条件就是临时数组的长度达到了k的目标阈值。

```python
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        result = []
        self.backtracking(n, k, 1, [], result)
        return result
    def backtracking(self, n, k, startIndex, temp, result):
        if len(temp) == k:
            result.append(temp[:])    # 使用[:]才能存上
            return
        for i in range(startIndex, n + 1):		# 在这里产生了不必要的遍历
            temp.append(i)
            self.backtracking(n, k, i + 1, temp, result)
            temp.pop()  # 保持初始状态
```

当然，虽然回溯就是穷举，但是为了优化性能，可以配合剪枝使用：如在n=4，k=4的情况下，后续的很多遍历都是无用的，如下图便于理解：

> ![77.组合4](./assets/20210130194335207-20230310134409532.png)

所以可以将其优化

```python
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        result = []
        self.backtracking(n, k, 1, [], result)
        return result
    def backtracking(self, n, k, startIndex, temp, result):
        if len(temp) == k:
            result.append(temp[:])    # 使用[:]才能存上
            return
        for i in range(startIndex, n - (k - len(temp)) + 2):	#优化的部分
            temp.append(i)
            self.backtracking(n, k, i + 1, temp, result)
            temp.pop()  # 保持初始状态
```



### 1090 - 组合总和 III<a id="p1090"></a>

#### 问题

找出所有相加之和为 `n` 的 `k` 个数的组合，且满足下列条件：

- 只使用数字1到9
- 每个数字 **最多使用一次** 

返回 *所有可能的有效组合的列表* 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。

 

**示例 1:**

```
输入: k = 3, n = 7
输出: [[1,2,4]]
解释:
1 + 2 + 4 = 7
没有其他符合的组合了。
```

**示例 2:**

```
输入: k = 3, n = 9
输出: [[1,2,6], [1,3,5], [2,3,4]]
解释:
1 + 2 + 6 = 9
1 + 3 + 5 = 9
2 + 3 + 4 = 9
没有其他符合的组合了。
```

**示例 3:**

```
输入: k = 4, n = 1
输出: []
解释: 不存在有效的组合。
在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 > 1，没有有效的组合。
```

 

#### 解法

递归，不包含剪枝

```python
class Solution:
    def breaktracking(self, k, n, startIndex, temp, result):
        if len(temp) == k and sum(temp) == n:
            result.append(temp[:])
            return
        for i in range(startIndex, 10):
            temp.append(i)
            self.breaktracking(k, n, i + 1, temp, result)
            temp.pop()
        
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        result = []
        self.breaktracking(k, n, 1, [], result)
        return result
```

剪枝优化

```python
class Solution:
    def breaktracking(self, k, n, startIndex, temp, result):
        if sum(temp) > n:
            return
        if len(temp) == k and sum(temp) == n:
            result.append(temp[:])
            return
        for i in range(startIndex, 9 - (k - len(temp)) + 2):
            temp.append(i)
            self.breaktracking(k, n, i + 1, temp, result)
            temp.pop()
        
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        result = []
        self.breaktracking(k, n, 1, [], result)
        return result
```



### 1091 - 电话号码的字母组合<a id="p1091"></a>

#### 问题

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![img](./assets/200px-telephone-keypad2svg.png)

 

**示例 1：**

```
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
```

**示例 2：**

```
输入：digits = ""
输出：[]
```

**示例 3：**

```
输入：digits = "2"
输出：["a","b","c"]
```



#### 解法

模板

```python
class Solution:
    def breaktracking(self, digits, startIndex, temp, result, lenth, lst):
        if startIndex == lenth:
            result.append(temp)
            return
        new_lst = lst[int(digits[startIndex])]
        for i in range(len(new_lst)):
            new_temp = temp + new_lst[i]
            self.breaktracking(digits, startIndex + 1, new_temp, result, lenth, lst)
            
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits:
            return []
        result = []
        lst = [[], [], ["a", "b", "c"], ["d", "e", "f"], ["g", "h", 'i'], ['j', 'k', 'l'], ['m', 'n', 'o'], ['p', 'q', 'r', 's'], ['t', 'u', 'v'], ['w', 'x', 'y', 'z']]
        self.breaktracking(digits, 0, "", result, len(digits), lst)
        return result
```



### 1092 - 组合总和<a id="p1092"></a>

#### 问题

给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。

`candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。

 

**示例 1：**

```
输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。
```

**示例 2：**

```
输入: candidates = [2,3,5], target = 8
输出: [[2,2,2,2],[2,3,3],[3,5]]
```

**示例 3：**

```
输入: candidates = [2], target = 1
输出: []
```



#### 解法

模板，未剪枝

```python
class Solution:
    def breaktracking(self, candidates, target, sums, startIndex, temp, result):
        if sums > target:
            return
        if sums == target:
            result.append(temp[:])
            return
        for i in range(startIndex, len(candidates)):
            sums += candidates[i]
            temp.append(candidates[i])
            self.breaktracking(candidates, target, sums, i, temp, result)
            temp.pop()
            sums -= candidates[i]
    
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        result = []
        self.breaktracking(candidates, target, 0, 0, [], result)
        return result
```

剪枝优化

```python
class Solution:
    def breaktracking(self, candidates, target, sums, startIndex, temp, result):
        if sums == target:
            result.append(temp[:])
            return
        for i in range(startIndex, len(candidates)):
            if sums + candidates[i] > target:
                return
            sums += candidates[i]
            temp.append(candidates[i])
            self.breaktracking(candidates, target, sums, i, temp, result)
            temp.pop()
            sums -= candidates[i]
    
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        result = []
        candidates.sort()
        self.breaktracking(candidates, target, 0, 0, [], result)
        return result
```

转换思路，不需要记录和，记录差值是否为0即可，少传递参数，剪枝优化后：

```python
# 递减
class Solution:
    def breaktracking(self, candidates, target, startIndex, temp, result):
        if target == 0:
            result.append(temp[:])
            return
        for i in range(startIndex, len(candidates)):
            if target -  candidates[i] < 0:
                return
            target -= candidates[i]
            temp.append(candidates[i])
            self.breaktracking(candidates, target, i, temp, result)
            temp.pop()
            target += candidates[i]
    
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        result = []
        candidates.sort()
        self.breaktracking(candidates, target, 0, [], result)
        return result
```



### 1093 - 组合总和 II<a id="p1093"></a>

#### 问题

给定一个候选人编号的集合 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。

`candidates` 中的每个数字在每个组合中只能使用 **一次** 。

**注意：**解集不能包含重复的组合。 

 

**示例 1:**

```
输入: candidates = [10,1,2,7,6,1,5], target = 8,
输出:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
```

**示例 2:**

```
输入: candidates = [2,5,2,1,2], target = 5,
输出:
[
[1,2,2],
[5]
]
```



#### 解法

使用排序，便于排除重复的元素，然后使用模板即可。

```python
class Solution:
    def breaktracking(self, candidates, target, startIndex, temp, result):
        if target == 0:
            result.append(temp[:])
            return
        for i in range(startIndex, len(candidates)):
            if target - candidates[i] < 0:
                return
            if i > startIndex and candidates[i] == candidates[i - 1]:
                continue
            temp.append(candidates[i])
            target -= candidates[i]
            self.breaktracking(candidates, target, i + 1, temp, result)
            target += candidates[i]
            temp.pop()

    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        candidates.sort()
        result = []
        self.breaktracking(candidates, target, 0, [], result)
        return result
```



### 1094 - 分割回文串<a id="p1094"></a>

#### 问题

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 

**回文串**

 。返回 `s` 所有可能的分割方案。



 

**示例 1：**

```
输入：s = "aab"
输出：[["a","a","b"],["aa","b"]]
```

**示例 2：**

```
输入：s = "a"
输出：[["a"]]
```

 

#### 解法

使用模板回溯即可，添加一个判断字符串是否为回文串即可。

```python
class Solution:
    def breaktracking(self, s, startIndex, temp, result):
        if startIndex == len(s):
            result.append(temp[:])
            return
        for i in range(startIndex, len(s)):
            if s[startIndex:i + 1] == s[startIndex:i + 1][::-1]:
                temp.append(s[startIndex:i + 1])
                self.breaktracking(s, i + 1, temp, result)
                temp.pop()
    def partition(self, s: str) -> List[List[str]]:
        result = []
        self.breaktracking(s, 0, [], result)
        return result
```

优化了判断回文串的流程：事先计算出该字符串是否为回文串即可。

> 例如给定字符串`"abcde"`, 在已知`"bcd"`不是回文字串时, 不再需要去双指针操作`"abcde"`而可以直接判定它一定不是回文字串。
>
> 具体来说, 给定一个字符串`s`, 长度为`n`, 它成为回文字串的充分必要条件是`s[0] == s[n-1]`且`s[1:n-1]`是回文字串。

```python
class Solution:
    # 本部分计算了字符串是否为回文串
    def computePalindrome(self, s, isPalindrome):
        for i in range(len(s) - 1, -1, -1):  # 需要倒序计算，保证在i行时，i+1行已经计算好了
            for j in range(i, len(s)):
                if j == i:
                    isPalindrome[i][j] = True
                elif j - i == 1:
                    isPalindrome[i][j] = (s[i] == s[j])
                else:
                    isPalindrome[i][j] = (s[i] == s[j] and isPalindrome[i+1][j-1])
    def breaktracking(self, s, startIndex, temp, result, isPalindrome):
        if startIndex == len(s):
            result.append(temp[:])
            return
        for i in range(startIndex, len(s)):
            # 此部分可以优化判断是否为回文串
            if isPalindrome[startIndex][i]:
                temp.append(s[startIndex:i + 1])
                self.breaktracking(s, i + 1, temp, result, isPalindrome)
                temp.pop()
    def partition(self, s: str) -> List[List[str]]:
        result = []
        isPalindrome = [[False] * len(s) for _ in range(len(s))]  # 初始化isPalindrome矩阵
        self.computePalindrome(s, isPalindrome)
        print(isPalindrome)
        self.breaktracking(s, 0, [], result, isPalindrome)
        return result
```

动态规划写法：过于逆天难以理解

```python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        dp = [[[]]]
        # dp[i]表示s[:i]所有可能的分割方案
        for i in range(1, len(s) + 1):
            dp.append([])
            for j in range(i):
                tmp = s[j:i]
                if tmp == tmp[::-1]:
                    for l in dp[j]:
                        dp[-1].append(l + [tmp])
        return dp[-1]
```



### 1095 - 复原 IP 地址<a id="p1095"></a>

#### 问题

**有效 IP 地址** 正好由四个整数（每个整数位于 `0` 到 `255` 之间组成，且不能含有前导 `0`），整数之间用 `'.'` 分隔。

- 例如：`"0.1.2.201"` 和` "192.168.1.1"` 是 **有效** IP 地址，但是 `"0.011.255.245"`、`"192.168.1.312"` 和 `"192.168@1.1"` 是 **无效** IP 地址。

给定一个只包含数字的字符串 `s` ，用以表示一个 IP 地址，返回所有可能的**有效 IP 地址**，这些地址可以通过在 `s` 中插入 `'.'` 来形成。你 **不能** 重新排序或删除 `s` 中的任何数字。你可以按 **任何** 顺序返回答案。

 

**示例 1：**

```
输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]
```

**示例 2：**

```
输入：s = "0000"
输出：["0.0.0.0"]
```

**示例 3：**

```
输入：s = "101023"
输出：["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]
```

 

#### 解法

使用模板，注意此处的剪枝优化极为重要，以及如何判断要添加的数字是否合法，以及什么条件下是最终结果。

```python
class Solution:
    def is_valid(self, s, start, end):
        if start > end:
            return False
        if s[start] == '0' and start != end:  # 0开头的数字不合法
            return False
        num = int(s[start:end+1])
        return 0 <= num <= 255

    def breaktrack(self, temp, result, startIndex, s):
        if startIndex == len(s) and len(temp) == 4:
            result.append(".".join(temp))
            return

        # 剪枝,优化很多很多
        if len(temp) > 4:
            return

        for i in range(startIndex, min(startIndex + 3, len(s))):
            # 前面的数字不到255,且不能为0开头的数字
            if self.is_valid(s, startIndex, i):
                temp.append(s[startIndex:i + 1])
                self.breaktrack(temp, result, i + 1, s)
                temp.pop()

    def restoreIpAddresses(self, s: str) -> List[str]:
        # 最深递归四层,控制在最后一层仍然有数字即可
        result = []
        self.breaktrack([], result, 0, s)
        return result
```



### 1096 - 子集<a id="p1096"></a>

#### 问题

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的

子集

（幂集）。



解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

 

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

**示例 2：**

```
输入：nums = [0]
输出：[[],[0]]
```

 

#### 解法

标准的模板

```python
class Solution:
    def breaktrack(self, temp, result, Index, nums):
        result.append(temp[:])

        for i in range(Index, len(nums)):
            temp.append(nums[i])
            self.breaktrack(temp, result, i + 1, nums)
            temp.pop()

    def subsets(self, nums: List[int]) -> List[List[int]]:
        result = []
        self.breaktrack([], result, 0, nums)
        return result
```



### 1097 - 子集 II<a id="p1097"></a>

#### 问题

给你一个整数数组 `nums` ，其中可能包含重复元素，请你返回该数组所有可能的 

子集

（幂集）。



解集 **不能** 包含重复的子集。返回的解集中，子集可以按 **任意顺序** 排列。

 

**示例 1：**

```
输入：nums = [1,2,2]
输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
```

**示例 2：**

```
输入：nums = [0]
输出：[[],[0]]
```

 

#### 解法

使用回溯模板以及set集合去重。

```python
class Solution:
    def breaktreack(self, nums, startIndex, temp, result):
        result.append(temp[:])
        used = set()
        for i in range(startIndex, len(nums)):
            if nums[i] in used:
                continue
            used.add(nums[i])
            self.breaktreack(nums[:i] + nums[i + 1:], i, temp + [nums[i]], result)

    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        result = []
        self.breaktreack(nums, 0, [], result)
        return result
```



### 1098 - 非递减子序列<a id="p1098"></a>

#### 问题

给你一个整数数组 `nums` ，找出并返回所有该数组中不同的递增子序列，递增子序列中 **至少有两个元素** 。你可以按 **任意顺序** 返回答案。

数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。

 

**示例 1：**

```
输入：nums = [4,6,7,7]
输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]
```

**示例 2：**

```
输入：nums = [4,4,3,2,1]
输出：[[4,4]]
```

 

#### 解法

使用回溯模板和Set集合去重

```python
class Solution:
    def breaktrack(self, nums, startIndex, temp, result):
        if len(temp) > 1:
            result.append(temp[:])
        used = set()
        for i in range(startIndex, len(nums)):
            if temp and nums[i] < temp[-1] or nums[i] in used:
                continue
            used.add(nums[i])
            self.breaktrack(nums, i + 1, temp + [nums[i]], result)

    def findSubsequences(self, nums: List[int]) -> List[List[int]]:
        result = []
        self.breaktrack(nums, 0, [], result)
        print(result)
        return result
```



### 1099 - 全排列<a id="p1099"></a>

#### 问题

给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

 

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**示例 2：**

```
输入：nums = [0,1]
输出：[[0,1],[1,0]]
```

**示例 3：**

```
输入：nums = [1]
输出：[[1]]
```

 

#### 解法

回溯模板，使用过就去掉

```python
class Solution:
    def breaktrack(self, nums, temp, result):
        if not nums:
            result.append(temp[:])
            return
        for i in range(len(nums)):
            new_nums = nums[:]
            new_nums.pop(i)
            self.breaktrack(new_nums, temp + [nums[i]], result)


    def permute(self, nums: List[int]) -> List[List[int]]:
        result = []
        self.breaktrack(nums, [], result)
        return result
```

使用used数组

```python
class Solution:
    def breaktrack(self, nums, temp, result, used):
        if len(temp) == len(nums):
            result.append(temp[:])
            return
        for i in range(len(nums)):
            if used[i]:
                continue
            used[i] = True
            self.breaktrack(nums, temp + [nums[i]], result, used)
            used[i] = False

    def permute(self, nums: List[int]) -> List[List[int]]:
        result = []
        self.breaktrack(nums, [], result, [False] * len(nums))
        return result
```



### 1100 - 全排列 II<a id="p1100"></a>

#### 问题

给定一个可包含重复数字的序列 `nums` ，***按任意顺序*** 返回所有不重复的全排列。

 

**示例 1：**

```
输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]
```

**示例 2：**

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

 

#### 解法

模板

```python
class Solution:
    def breaktrack(self, nums, temp, result, used):
        if len(nums) == len(temp):
            result.append(temp[:])
            return
        for i in range(len(nums)):
            # 相同的元素，本层已经使用过
            if used[i] or (i != 0 and nums[i] == nums[i - 1] and not used[i - 1]):
                continue
            used[i] = True
            self.breaktrack(nums, temp + [nums[i]], result, used)
            used[i] = False

    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        result = []
        self.breaktrack(nums, [], result, [False] * len(nums))
        return result
```



### 1101 - 二叉树的层序遍历 II<a id="p1101"></a>

#### 问题

给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

 

**示例 1：**

![img](./assets/tree1-1710675771006-1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：[[15,7],[9,20],[3]]
```

**示例 2：**

```
输入：root = [1]
输出：[[1]]
```

**示例 3：**

```
输入：root = []
输出：[]
```

 

#### 解法

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        # 偷懒
        if not root:
            return []
        queue = collections.deque([root])
        result = []
        while queue:
            level = []
            for _ in range(len(queue)):
                cur = queue.popleft()
                level.append(cur.val)
                if cur.left:
                    queue.append(cur.left)
                if cur.right:
                    queue.append(cur.right)
            result.append(level)
        return result[::-1]
```



### 1102 - 重新安排行程<a id="p1102"></a>

#### 问题

给你一份航线列表 `tickets` ，其中 `tickets[i] = [fromi, toi]` 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。

所有这些机票都属于一个从 `JFK`（肯尼迪国际机场）出发的先生，所以该行程必须从 `JFK` 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。

- 例如，行程 `["JFK", "LGA"]` 与 `["JFK", "LGB"]` 相比就更小，排序更靠前。

假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。

 

**示例 1：**

![img](./assets/itinerary1-graph.jpg)

```
输入：tickets = [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]
输出：["JFK","MUC","LHR","SFO","SJC"]
```

**示例 2：**

![img](./assets/itinerary2-graph.jpg)

```
输入：tickets = [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]
输出：["JFK","ATL","JFK","SFO","ATL","SFO"]
解释：另一种有效的行程是 ["JFK","SFO","ATL","JFK","ATL","SFO"] ，但是它字典排序更大更靠后。
```

 

#### 解法

暴力

```python
class Solution:
    def Judgerode(self, tickets, start):
        temp = []
        for i in range(len(tickets)):
            if tickets[i][0] == start:
                temp.append(tickets[i])
                return True
        return False

    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        from collections import deque
        # 寻找头节点，筛选字典
        tickets.sort()
        tickets = collections.deque(tickets)
        result = ["JFK"]
        used = [False] * len(tickets)
        while tickets:
            start = result[-1]
            temp = collections.deque()
            for i in range(len(tickets)):
                # 如果起点是上一个终点，将终点纳入
                if tickets[i][0] == start:
                    temp.append(tickets[i])
            # 判断下一个节点在剩余票数不为空的情况下是否有路
            # 特殊处理最后一个节点
            for i in temp:
                # 在剩余机票不为空的情况下，
                if self.Judgerode(tickets, i[-1]) or len(tickets) == 1:
                    tickets.remove(i)
                    result.append(i[-1])
                    break
        return result
```

回溯 使用字典 逆序

```python
from collections import defaultdict

class Solution:
    def findItinerary(self, tickets):
        targets = defaultdict(list)  # 创建默认字典，用于存储机场映射关系
        for ticket in tickets:
            targets[ticket[0]].append(ticket[1])  # 将机票输入到字典中
        
        for key in targets:
            targets[key].sort(reverse=True)  # 对到达机场列表进行字母逆序排序
        
        result = []
        self.backtracking("JFK", targets, result)  # 调用回溯函数开始搜索路径
        return result[::-1]  # 返回逆序的行程路径
    
    def backtracking(self, airport, targets, result):
        while targets[airport]:  # 当机场还有可到达的机场时
            next_airport = targets[airport].pop()  # 弹出下一个机场
            self.backtracking(next_airport, targets, result)  # 递归调用回溯函数进行深度优先搜索
        result.append(airport)  # 将当前机场添加到行程路径中

```



### 1103 - N皇后<a id="p1102"></a>

#### 问题

按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。

**n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。

每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。

 

**示例 1：**

![img](./assets/queens.jpg)

```
输入：n = 4
输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
解释：如上图所示，4 皇后问题存在两个不同的解法。
```

**示例 2：**

```
输入：n = 1
输出：[["Q"]]
```

 

#### 解法

回溯模板

思路：将n*n大小的二维数组，全部赋值为0，然后使用回溯即可，每次棋盘发生变化，即实时将棋盘更新：即将同列、同斜线的位置赋值为”.“（同行不需要更改，一是方便回溯，二是后续必定为”.“），最后得到的结果必定为所求，再根据得到的”Q“、”.“数组转换成字符串即可。

注意：对于方法的传参，如果是数组的话，传递的会是内存地址，也就是相当于C语言的指针。

对于列表里面掺列表，使用`copy`库的深拷贝功能即可将值完全复制。

```python
import copy
class Solution:
    import copy
    def breaktrack(self, n, temp, result, Index):
        def refresh(temp, x, y, n):
            # 只处理同列,同斜线即可
            # 处理同列
            for i in range(n):
                if temp[i][y] == 1:
                    return
                temp[i][y] = "."
            # 处理斜线,向左下角和右上角延申
            # up, down, left, right = x - 1, x + 1, y - 1, y + 1
            # 先处理左上角
            up, left = x - 1, y - 1
            while up > -1 and left > -1:
                if temp[up][left] == "Q":
                    return
                temp[up][left] = "."
                up, left = up - 1, left - 1
            # 处理右上角
            up, right = x - 1, y + 1
            while up > -1 and right < n:
                if temp[up][right] == 'Q':
                    return
                temp[up][right] = "."
                up, right = up -1, right + 1
            # 处理左下角
            down, left = x + 1, y - 1
            while down < n and left > -1:
                if temp[down][left] == "Q":
                    return
                temp[down][left] = "."
                down, left = down + 1, left - 1
            # 再处理右下角
            down, right = x + 1, y + 1
            while down < n and right < n:
                if temp[down][right] == "Q":
                    return
                temp[down][right] = "."
                down, right = down + 1, right + 1
            return temp

        if Index == n:
            result.append(temp[:])
            return
        for i in range(n):
            # 传入坐标判断该位置是否合法
            # Index就是x, i就是y
            if temp[Index][i] == 0:
                new_temp = copy.deepcopy(refresh(copy.deepcopy(temp), Index, i, n))
                if not new_temp:
                    continue
                new_temp[Index][i] = "Q"
                self.breaktrack(n, new_temp, result, Index + 1)

    def solveNQueens(self, n: int) -> List[List[str]]:
        # 不能出现同行、同列、同斜线，可以使用一个二维数组规避坐标
        # 实时更新规避数组或每次判断    这里使用规避数组
        # 要么同数组规避，要么本数组规避
        # 先本数组更新
        result = []
        # 空的为0,有棋子的地方置为1,不可占用的位置即为-1
        temp = [[0] * n for _ in range(n)]
        self.breaktrack(n, temp, result, 0)
        # 这里需要再对result进行处理
        for i in range(len(result)):
            for j in range(len(result[i])):
                result[i][j] = "".join(result[i][j])
        return result
```

代码随想录的做法：验证当前棋盘状态是否合法，比上述解法要快一点。参考：[代码随想录](https://www.programmercarl.com/0051.N皇后.html#算法公开课)

```python
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        result = []  # 存储最终结果的二维字符串数组

        chessboard = ['.' * n for _ in range(n)]  # 初始化棋盘
        self.backtracking(n, 0, chessboard, result)  # 回溯求解
        return [[''.join(row) for row in solution] for solution in result]  # 返回结果集

    def backtracking(self, n: int, row: int, chessboard: List[str], result: List[List[str]]) -> None:
        if row == n:
            result.append(chessboard[:])  # 棋盘填满，将当前解加入结果集
            return

        for col in range(n):
            if self.isValid(row, col, chessboard):
                chessboard[row] = chessboard[row][:col] + 'Q' + chessboard[row][col+1:]  # 放置皇后
                self.backtracking(n, row + 1, chessboard, result)  # 递归到下一行
                chessboard[row] = chessboard[row][:col] + '.' + chessboard[row][col+1:]  # 回溯，撤销当前位置的皇后

    def isValid(self, row: int, col: int, chessboard: List[str]) -> bool:
        # 检查列
        for i in range(row):
            if chessboard[i][col] == 'Q':
                return False  # 当前列已经存在皇后，不合法

        # 检查 45 度角是否有皇后
        i, j = row - 1, col - 1
        while i >= 0 and j >= 0:
            if chessboard[i][j] == 'Q':
                return False  # 左上方向已经存在皇后，不合法
            i -= 1
            j -= 1

        # 检查 135 度角是否有皇后
        i, j = row - 1, col + 1
        while i >= 0 and j < len(chessboard):
            if chessboard[i][j] == 'Q':
                return False  # 右上方向已经存在皇后，不合法
            i -= 1
            j += 1

        return True  # 当前位置合法
```



### 1104 - 解数独<a id="p1104"></a>

#### 问题

编写一个程序，通过填充空格来解决数独问题。

数独的解法需 **遵循如下规则**：

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。（请参考示例图）

数独部分空格内已填入了数字，空白格用 `'.'` 表示。

 

**示例 1：**

![img](./assets/250px-sudoku-by-l2g-20050714svg.png)

```
输入：board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]
输出：[["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]
解释：输入的数独如上图所示，唯一有效的解决方案如下所示： 
```

![img](./assets/250px-sudoku-by-l2g-20050714_solutionsvg.png)



#### 解法

参考：[代码随想录 ](https://www.programmercarl.com/0037.解数独.html#算法公开课)

最开始的思路时通过模板解决，但是出现一个问题：如果遇到思路无法回溯，错误方法的参考如下

```python
def breaktrack(self, board, Index, startIndex):
        if Index == 9:
            return
        if startIndex == 9:
            self.breaktrack(board, Index + 1, 0)
        else:
            if board[Index][startIndex] == ".":
                for num in range(1, 10):
                    board[Index][startIndex] = num
                    self.breaktrack(board, Index, startIndex + 1)
            else:
                self.breaktrack(board, Index, startIndex + 1)
```

上述代码是无法回返的，所以参考代码随想录的思路：



```python
class Solution:
    # 判断当前位置是否合法
    def judgelocation(self, board, Index, x, num):
        # 同行，同列不能有相同的值
        for i in range(9):
            if board[Index][i] == num or board[i][x] == num:
                return False
        # 所处九宫格内不能包含相同数字
        # 判断在第几个九宫格内
        start_x, start_y = (x // 3) * 3, (Index // 3) * 3
        for i in range(start_y, start_y + 3):
            for j in range(start_x, start_x + 3):
                if board[i][j] == num:
                    return False
        return True

    def breaktrack(self, board):
        for i in range(9):
            for j in range(9):
                if board[i][j] != ".":
                    continue
                for k in range(1, 10):
                    if self.judgelocation(board, i, j, str(k)):
                        board[i][j] = str(k)
                        if self.breaktrack(board):
                            # 如果找到合适一组立刻返回
                            return True
                        board[i][j] = "."
                # 若数字1-9都不能成功填入空格，返回False无解
                return False
        # 遍历完没有返回false，说明找到了合适棋盘位置了
        return True
    def solveSudoku(self, board: List[List[str]]) -> None:
        # 回溯验证当前棋盘状态是否合法即可
        self.breaktrack(board)
```



### 1105 - 分发饼干<a id="p1105"></a>

问题

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 `i`，都有一个胃口值 `g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `j`，都有一个尺寸 `s[j]` 。如果 `s[j] >= g[i]`，我们可以将这个饼干 `j` 分配给孩子 `i` ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

 

**示例 1:**

```
输入: g = [1,2,3], s = [1,1]
输出: 1
解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。
```

**示例 2:**

```
输入: g = [1,2], s = [1,2,3]
输出: 2
解释: 
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.
```

 

#### 解法

先满足小的，此时需要遍历饼干，则此时移动的是饼干，不动的是小孩。

```python
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        # 先从最小的开始满足
        result = 0
        g.sort()
        s.sort()
        child = 0
        for biscuit in s:
            if child < len(g) and g[child] <= biscuit:
                result += 1
                child += 1
        return result
```

先满足大的，需要遍历小孩，此时移动的饼干，小孩不动。

```python
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        # 先满足大的
        s.sort()
        g.sort()
        biscuit = len(s) - 1
        result = 0
        for child in g[::-1]:
            if biscuit > -1 and child <= s[biscuit]:
                result += 1
                biscuit -= 1
        return result
```



### 1106 - 摆动序列<a id="p1106"></a>

#### 问题

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

- 例如， `[1, 7, 4, 9, 2, 5]` 是一个 **摆动序列** ，因为差值 `(6, -3, 5, -7, 3)` 是正负交替出现的。
- 相反，`[1, 4, 7, 2, 5]` 和 `[1, 7, 4, 5, 5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

**子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 `nums` ，返回 `nums` 中作为 **摆动序列** 的 **最长子序列的长度** 。

 

**示例 1：**

```
输入：nums = [1,7,4,9,2,5]
输出：6
解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。
```

**示例 2：**

```
输入：nums = [1,17,5,10,13,15,10,5,16,8]
输出：7
解释：这个序列包含几个长度为 7 摆动序列。
其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。
```

**示例 3：**

```
输入：nums = [1,2,3,4,5,6,7,8,9]
输出：2
```

 

#### 解法

直接计算：先求出差值数组，再根据差值数组处理即可，问题在于其中的0很难处理。

```python
class Solution:    
    def wiggleMaxLength(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return len(nums)
        # 计算差值列表
        new_nums = []
        for i in range(1, len(nums)):
            new_nums.append(nums[i] - nums[i - 1])
        while 0 in new_nums:
            new_nums.remove(0)
        if not new_nums:
            return 1
        result = len(new_nums) + 1
        if new_nums[0] == 0:
            result -= 1
        for i in range(1, len(new_nums)):
            if (new_nums[i] > 0 and new_nums[i - 1] > 0) or (new_nums[i] < 0 and new_nums[i - 1] < 0):
                result -= 1
            if new_nums[i] == 0:
                result -= 2
        return result
```

将问题转化为数学问题即可：这里的摆动序列，实际上就是均是极大值或极小值即可，那么怎么处理呢？只要将所有非极值的点去掉即可，剩下的节点数量就是最终答案。

该思路由代码随想录提供：[代码随想录 ](https://www.programmercarl.com/0376.摆动序列.html#思路)

```python
class Solution:
    def wiggleMaxLength(self, nums):
        if len(nums) <= 1:
            return len(nums)  # 如果数组长度为0或1，则返回数组长度
        curDiff = 0  # 当前一对元素的差值
        preDiff = 0  # 前一对元素的差值
        result = 1  # 记录峰值的个数，初始为1（默认最右边的元素被视为峰值）
        for i in range(len(nums) - 1):
            curDiff = nums[i + 1] - nums[i]  # 计算下一个元素与当前元素的差值
            # 如果遇到一个峰值
            if (preDiff <= 0 and curDiff > 0) or (preDiff >= 0 and curDiff < 0):
                result += 1  # 峰值个数加1
                preDiff = curDiff  # 注意这里，只在摆动变化的时候更新preDiff
        return result  # 返回最长摆动子序列的长度
```

另一种判断方法

```python
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        if len(nums) <= 1:
            return len(nums)  # 如果数组长度为0或1，则返回数组长度
        preDiff,curDiff ,result  = 0,0,1  #题目里nums长度大于等于1，当长度为1时，其实到不了for循环里去，所以不用考虑nums长度
        for i in range(len(nums) - 1):
            curDiff = nums[i + 1] - nums[i]
            if curDiff * preDiff <= 0 and curDiff !=0:  #差值为0时，不算摆动
                result += 1
                preDiff = curDiff  #如果当前差值和上一个差值为一正一负时，才需要用当前差值替代上一个差值
        return result
```



### 1107 - 最大子数组和<a id="p1107"></a>

#### 问题

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。



**子数组**

是数组中的一个连续部分。



 

**示例 1：**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

**示例 2：**

```
输入：nums = [1]
输出：1
```

**示例 3：**

```
输入：nums = [5,4,-1,7,8]
输出：23
```

 

#### 解法

> 局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。
>
> 全局最优：选取最大“连续和”

```python
class Solution:
    def maxSubArray(self, nums):
        result = float('-inf')  # 初始化结果为负无穷大
        count = 0
        for i in range(len(nums)):
            count += nums[i]
            if count > result:  # 取区间累计的最大值（相当于不断确定最大子序终止位置）
                result = count
            if count <= 0:  # 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和
                count = 0
        return result
```



### 1108 - 买卖股票的最佳时机 II<a id="p1108"></a>

#### 问题

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。

返回 *你能获得的 **最大** 利润* 。

 

**示例 1：**

```
输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
     总利润为 4 + 3 = 7 。
```

**示例 2：**

```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     总利润为 4 。
```

**示例 3：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。
```

 

#### 解法

局部最优：低价买入，高价卖出，每日更新最低价格

全局最优：求总和

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # 低价买入，高价卖出
        # 局部最优：遇到上涨卖出，遇到下跌重新计数
        result = 0
        min_price = float("inf")
        for i ina range(len(prices)):
            if prices[i] < min_price:
                min_price = prices[i]
            elif prices[i] > min_price:
                result += prices[i] - min_price
                min_price = prices[i]
        return result
```

利润可以分解，比如周一买周三卖，可以换算成周一买，周二卖，周二买，周三卖，最后只统计正数结果即可。

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        result = 0
        for i in range(1, len(prices)):
            result += max(prices[i] - prices[i - 1], 0)
        return result
```

动态规划：与上一次股票交易不同的是，这次交易可以多次买入卖出但是一日内最多持有一只股票；对于动态规划的推导式而言，不同的是：如果选择当日买入，那么今日持有的金额应该为昨日不持有股票时（昨日若持有股票则今日无法买入，否则会造成当日持有两只股票）剩余的金额减去今日的股票价格。

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        dp = [[0] * 2 for _ in range(len(prices))]
        dp[0] = [0, -prices[0]]
        for i in range(1, len(prices)):
            # 与上一题不同的是：在当天持有股票的情况下：如果选择买入当天股票，那么拥有的金额为以前的现金减去今日股票价格
            dp[i] = [max(dp[i - 1][0], prices[i] + dp[i - 1][1]), max(dp[i - 1][1], dp[i - 1][0] - prices[i])]
        return max(dp[-1])
```





### 1109 - 跳跃游戏<a id="p1109"></a>

#### 问题

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

 

**示例 1：**

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

**示例 2：**

```
输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
```

 

#### 解法

不需要模拟，只需要记录最大覆盖范围即可。

使用for循环记录最大覆盖范围：

```python
## for循环
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        cover = 0
        if len(nums) == 1: return True
        for i in range(len(nums)):
            if i <= cover:
                cover = max(i + nums[i], cover)
                if cover >= len(nums) - 1: return True
        return False
```

使用While循环计算覆盖范围，那么while循环的条件就是索引不得超过覆盖范围。

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        cover = 0
        if len(nums) == 1: return True
        i = 0
        # 动态更新最大覆盖范围即可。
        while i <= cover:
            cover = max(i + nums[i], cover)
            if cover >= len(nums) - 1: return True
            i += 1
        return False
```



### 1110 - 跳跃游戏 II<a id="p1110"></a>

#### 问题

给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。

每个元素 `nums[i]` 表示从索引 `i` 向前跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:

- `0 <= j <= nums[i]` 
- `i + j < n`

返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。

 

**示例 1:**

```
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

**示例 2:**

```
输入: nums = [2,3,0,1,4]
输出: 2
```

 

#### 解法

每当最大覆盖范围更新后，即将步数加一

```python
class Solution:
    def jump(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return 0
        # 局部最优：最大覆盖区域，最大覆盖区域内部的节点的最大覆盖区域，真贪心
        # 全局最优：计算cover更新次数
        result = 0
        cur, next_ = 0, 0
        for i in range(len(nums)):
            next_ = max(next_, i + nums[i])
            if i == cur:
                result += 1
                cur = next_
                if cur >= len(nums) - 1:
                    break
        return result
```



### 1111 - K次取反后最大化的数组和<a id="p1111"></a>

#### 问题

给你一个整数数组 `nums` 和一个整数 `k` ，按以下方法修改该数组：

- 选择某个下标 `i` 并将 `nums[i]` 替换为 `-nums[i]` 。

重复这个过程恰好 `k` 次。可以多次选择同一个下标 `i` 。

以这种方式修改数组后，返回数组 **可能的最大和** 。

 

**示例 1：**

```
输入：nums = [4,2,3], k = 1
输出：5
解释：选择下标 1 ，nums 变为 [4,-2,3] 。
```

**示例 2：**

```
输入：nums = [3,-1,0,2], k = 3
输出：6
解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。
```

**示例 3：**

```
输入：nums = [2,-3,-1,5,-4], k = 2
输出：13
解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。
```

 

#### 解法

依照条件判断即可

```python
class Solution:
    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:
        nums.sort()
        # 如果有负数，优先将负数调整为整数，没有负数的时候，将初始值修改
        index = 0
        while k > 0:
            if index >= len(nums) or nums[index] > 0:
                nums.sort()
                # 优化部分
                while k > 0:
                    nums[0] = nums[0] * -1
                    k -= 1
                break
            elif nums[index] < 0:
                nums[index] = nums[index] * -1
                index += 1
                k -= 1
            # 优化部分
            elif nums[index] == 0:
                break
        return sum(nums)
```



### 1112 - 加油站<a id="p1112"></a>

#### 问题

在一条环路上有 `n` 个加油站，其中第 `i` 个加油站有汽油 `gas[i]` 升。

你有一辆油箱容量无限的的汽车，从第 `i` 个加油站开往第 `i+1` 个加油站需要消耗汽油 `cost[i]` 升。你从其中的一个加油站出发，开始时油箱为空。

给定两个整数数组 `gas` 和 `cost` ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 `-1` 。如果存在解，则 **保证** 它是 **唯一** 的。

 

**示例 1:**

```
输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
输出: 3
解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引。
```

**示例 2:**

```
输入: gas = [2,3,4], cost = [3,4,3]
输出: -1
解释:
你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
因此，无论怎样，你都不可能绕环路行驶一周。
```

 

#### 解法

暴力解法，超时，但是通过测试用例不少。

```python
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        for start in range(len(gas)):
            # 初始油量
            power = gas[start] - cost[(start)]
            index = (start + 1) % len(gas)
            while index != start and power > 0:
                power = power + gas[index] - cost[index]
                index = (index + 1) % len(gas)
            if index == start and power >= 0:
                return start
        return -1
```

这个思路来自于代码随想录，构成即为巧妙。

从零节点开始统计：旅途的最小油量、最终的剩余油量。

通过最终的剩余油量可以统计，一圈的耗油量大还是补油量大。

通过最小油量判断从当前节点出发是否可以完成一圈（如果最小的油量是负数就证明从当前的节点出发不能完成一圈）

当最小油量为负数时，可以倒退循环，并且将那一天的剩余油量和最小油量相加，如果为负数就继续倒退，如果最后为正数就说明该节点出发可以完成一圈。

因为倒退的过程中也在完善最小油量，无论如何是要完成一圈的，所以只要最小油量并非负数即可。

```python
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        curSum = 0  # 当前累计的剩余油量
        minFuel = float('inf')  # 从起点出发，油箱里的油量最小值
        
        for i in range(len(gas)):
            rest = gas[i] - cost[i]
            curSum += rest
            if curSum < minFuel:
                minFuel = curSum
        
        if curSum < 0:
            return -1  # 情况1：整个行程的总消耗大于总供给，无法完成一圈
        
        if minFuel >= 0:
            return 0  # 情况2：从起点出发到任何一个加油站时油箱的剩余油量都不会小于0，可以从起点出发完成一圈
        
        for i in range(len(gas) - 1, -1, -1):
            rest = gas[i] - cost[i]
            minFuel += rest
            if minFuel >= 0:
                return i  # 情况3：找到一个位置使得从该位置出发油箱的剩余油量不会小于0，返回该位置的索引
        
        return -1  # 无法完成一圈
```

真•贪心

参考：[代码随想录 ](https://www.programmercarl.com/0134.加油站.html#思路)

从头开始遍历，记录当前的剩余油量和最终油量。

一旦当前的剩余油量是负数，则证明从上一个起始节点开始到当前节点的任何一个点都不能完成一圈，因为到当前节点必定为负数；所以需要再从当前节点+1开始遍历，最终结束，如果最后最终油量是负数证明无论如何也不能完成一圈。

```python
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        curSum = 0  # 当前累计的剩余油量
        totalSum = 0  # 总剩余油量
        start = 0  # 起始位置
        
        for i in range(len(gas)):
            curSum += gas[i] - cost[i]
            totalSum += gas[i] - cost[i]
            
            if curSum < 0:  # 当前累计剩余油量curSum小于0
                start = i + 1  # 起始位置更新为i+1
                curSum = 0  # curSum重新从0开始累计
        
        if totalSum < 0:
            return -1  # 总剩余油量totalSum小于0，说明无法环绕一圈
        return start
```



### 1113 - 柠檬水找零<a id="p1113"></a>

#### 问题

在柠檬水摊上，每一杯柠檬水的售价为 `5` 美元。顾客排队购买你的产品，（按账单 `bills` 支付的顺序）一次购买一杯。

每位顾客只买一杯柠檬水，然后向你付 `5` 美元、`10` 美元或 `20` 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 `5` 美元。

注意，一开始你手头没有任何零钱。

给你一个整数数组 `bills` ，其中 `bills[i]` 是第 `i` 位顾客付的账。如果你能给每位顾客正确找零，返回 `true` ，否则返回 `false` 。

 

**示例 1：**

```
输入：bills = [5,5,5,10,20]
输出：true
解释：
前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。
第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。
第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。
由于所有客户都得到了正确的找零，所以我们输出 true。
```

**示例 2：**

```
输入：bills = [5,5,10,10,20]
输出：false
解释：
前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。
对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。
对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。
由于不是每位顾客都得到了正确的找零，所以答案是 false。
```



#### 解法

注意，顾客购买是有顺序的，必须以当时的余额还清。

```python
class Solution:
    def lemonadeChange(self, bills: List[int]) -> bool:
        five, ten = 0, 0
        for i in bills:
            if i == 5:
                five += 1
            elif i == 10:
                if five == 0:
                    return False
                ten += 1
                five -= 1
            elif i == 20:
                if five > 0 and ten > 0:
                    ten -= 1
                    five -= 1
                elif five >= 3:
                    five -= 3
                else:
                    return False
        return True
```



### 1114 - 发发糖果<a id="p1114"></a>

#### 问题

`n` 个孩子站成一排。给你一个整数数组 `ratings` 表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

- 每个孩子至少分配到 `1` 个糖果。
- 相邻两个孩子评分更高的孩子会获得更多的糖果。

请你给每个孩子分发糖果，计算并返回需要准备的 **最少糖果数目** 。

 

**示例 1：**

```
输入：ratings = [1,0,2]
输出：5
解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。
```

**示例 2：**

```
输入：ratings = [1,2,2]
输出：4
解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。
     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。
```

 

#### 解法

先从左向右遍历，遇到右侧评分比左侧评分大的多分一个糖果即可；再从右向左遍历，遇到左侧评分值比右侧评分大的话，再比较左侧孩子的糖果数量是否大于右侧孩子，否则便+1。

```python
class Solution:
    def candy(self, ratings: List[int]) -> int:
        # 处理头尾
        result = [1] * len(ratings)
        for i in range(1, len(ratings)):
            if ratings[i] > ratings[i - 1]:
                result[i] = result[i - 1] + 1
        
        # 从后往前遍历，处理左侧比右侧大的情况
        for i in range(len(ratings) - 2, -1, -1):
            if ratings[i] > ratings[i + 1]:
                result[i] = max(result[i], result[i + 1] + 1)
        
        return sum(result)
```



### 1115 - 根据身高重建队列<a id="p1115"></a>

#### 问题

假设有打乱顺序的一群人站成一个队列，数组 `people` 表示队列中一些人的属性（不一定按顺序）。每个 `people[i] = [hi, ki]` 表示第 `i` 个人的身高为 `hi` ，前面 **正好** 有 `ki` 个身高大于或等于 `hi` 的人。

请你重新构造并返回输入数组 `people` 所表示的队列。返回的队列应该格式化为数组 `queue` ，其中 `queue[j] = [hj, kj]` 是队列中第 `j` 个人的属性（`queue[0]` 是排在队列前面的人）。

 

**示例 1：**

```
输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
解释：
编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。
```

**示例 2：**

```
输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]
```

 

#### 解法

对于多维问题，一定要固定一维再考虑其他维度的问题。

根据题目要求，传递的列表第一个值是身高，第二个是前面还有多少个比当前身高高或者相等的。

那么可以先固定住身高，让身高通过倒序排序，再用索引k值正序排序。

排序后，可以按照顺序插入，索引即为k，这样可以保证插入的位置正确而且符合要求。

```python
class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        people.sort(key = lambda x: (-x[0], x[1]))
        que = []

        for p in people:
            que.insert(p[1], p)
        return que
```



### 1116 - 用最少数量的箭引爆气球<a id="p1116"></a>

#### 问题

有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 `points` ，其中`points[i] = [xstart, xend]` 表示水平直径在 `xstart` 和 `xend`之间的气球。你不知道气球的确切 y 坐标。

一支弓箭可以沿着 x 轴从不同点 **完全垂直** 地射出。在坐标 `x` 处射出一支箭，若有一个气球的直径的开始和结束坐标为 `x``start`，`x``end`， 且满足  `xstart ≤ x ≤ x``end`，则该气球会被 **引爆** 。可以射出的弓箭的数量 **没有限制** 。 弓箭一旦被射出之后，可以无限地前进。

给你一个数组 `points` ，*返回引爆所有气球所必须射出的 **最小** 弓箭数* 。

 

**示例 1：**

```
输入：points = [[10,16],[2,8],[1,6],[7,12]]
输出：2
解释：气球可以用2支箭来爆破:
-在x = 6处射出箭，击破气球[2,8]和[1,6]。
-在x = 11处发射箭，击破气球[10,16]和[7,12]。
```

**示例 2：**

```
输入：points = [[1,2],[3,4],[5,6],[7,8]]
输出：4
解释：每个气球需要射出一支箭，总共需要4支箭。
```

**示例 3：**

```
输入：points = [[1,2],[2,3],[3,4],[4,5]]
输出：2
解释：气球可以用2支箭来爆破:
- 在x = 2处发射箭，击破气球[1,2]和[2,3]。
- 在x = 4处射出箭，击破气球[3,4]和[4,5]。
```

 

#### 解法

通过计算最大堆叠数量，精髓在于处理堆叠的右侧边界。

```python
class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        points.sort()
        result = 1
        for i in range(1, len(points)):
            if points[i][0] > points[i - 1][1]:
                # 堆叠结束
                result += 1
            else:
                # 更新堆叠处的最小边界
                points[i][1] = min(points[i - 1][1], points[i][1])
        return result
```

确定右侧边界，一旦更新边界则说明需要再射出一箭。

```python
class Solution: # 不改变原数组
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        points.sort()
        r = points[0][1]
        count = 1
        for i in points:
            if i[0]>r:
                count+=1
                r = i[1]
            else:
                r = min(r,i[1])
        return count
```

简化版

```python
class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        sorted_points = sorted(points, key=lambda point: point[1])

        pivot = sorted_points[0][1]

        res = 1

        for line in sorted_points:
            if line[0] > pivot:
                res += 1
                pivot = line[1]
        return res
```



### 1117 - 无重叠区间<a id="p1117"></a>

#### 问题

给定一个区间的集合 `intervals` ，其中 `intervals[i] = [starti, endi]` 。返回 *需要移除区间的最小数量，使剩余区间互不重叠* 。

 

**示例 1:**

```
输入: intervals = [[1,2],[2,3],[3,4],[1,3]]
输出: 1
解释: 移除 [1,3] 后，剩下的区间没有重叠。
```

**示例 2:**

```
输入: intervals = [ [1,2], [1,2], [1,2] ]
输出: 2
解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。
```

**示例 3:**

```
输入: intervals = [ [1,2], [2,3] ]
输出: 0
解释: 你不需要移除任何区间，因为它们已经是无重叠的了。
```

 

#### 解法

遍历当前的区间是否与上一个区间重合即可，精髓在于对冲突区间的处理。

```python
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        intervals.sort()
        result = 0
        for i in range(1, len(intervals)):
            if intervals[i][0] < intervals[i - 1][1]:
                result += 1
                intervals[i][1] = min(intervals[i][1], intervals[i - 1][1])
        return result
```



### 1118 - 划分字母区间<a id="p1118"></a>

#### 问题

给你一个字符串 `s` 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。

注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 `s` 。

返回一个表示每个字符串片段的长度的列表。

 

**示例 1：**

```
输入：s = "ababcbacadefegdehijhklij"
输出：[9,7,8]
解释：
划分结果为 "ababcbaca"、"defegde"、"hijhklij" 。
每个字母最多出现在一个片段中。
像 "ababcbacadefegde", "hijhklij" 这样的划分是错误的，因为划分的片段数较少。 
```

**示例 2：**

```
输入：s = "eccbbbbdec"
输出：[10]
```

 

#### 解法

比以前的问题多了一道工序：求出字母的出现的起末位置，然后利用重复区间解决即可。

```python
class Solution:
    def partitionLabels(self, s: str) -> List[int]:
        # 使用collections模块中的defaultdict字典进行优化
        from collections import defaultdict
        # 求出每个字母的起始和结束位置
        dirt = defaultdict(list)
        for i in range(len(s)):
            if s[i] not in dirt:
                dirt[s[i]] = [i, i]
            else:
                dirt.get(s[i])[1] = i
        # 处理后的字母列表
        letter = []
        for i in dirt.values():
            letter.append(i)

        result = []
        l, r = letter[0][0], letter[0][1]
        for i in letter:
            # 如果冲突就更新边界
            if i[0] < r:
                r = max(r, i[1])
            elif i[0] > r:
                result.append(r - l + 1)
                l, r = i[0], i[1]
        result.append(r - l + 1)
        return result
```



### 1119 - 合并区间<a id="p1119"></a>

#### 问题

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。

 

**示例 1：**

```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**示例 2：**

```
输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
```

 

#### 解法

重复区间问题

```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        result = []
        intervals.sort()
        l, r = intervals[0][0], intervals[0][1]
        for i in intervals:
            if i[0] <= r:
                r = max(r, i[1])
            else:
                result.append([l, r])
                l, r = i[0], i[1]
        result.append([l, r])
        return result
```

优化后：不需要中间变量

```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort()
        result = [intervals[0]]
        for i in range(1, len(intervals)):
            if result[-1][1] >= intervals[i][0]:
                result[-1][1] = max(result[-1][1], intervals[i][1])
            else:
                result.append(intervals[i])
        return result
```



### 1120 - 单调递增的数字<a id="p1120"></a>

#### 问题

当且仅当每个相邻位数上的数字 `x` 和 `y` 满足 `x <= y` 时，我们称这个整数是**单调递增**的。

给定一个整数 `n` ，返回 *小于或等于 `n` 的最大数字，且数字呈 **单调递增*** 。

 

**示例 1:**

```
输入: n = 10
输出: 9
```

**示例 2:**

```
输入: n = 1234
输出: 1234
```

**示例 3:**

```
输入: n = 332
输出: 299
```

 

#### 解法

最后向前遍历，如果遇到不平衡的地方则将以后的值设置为9

```python
class Solution:
    def monotoneIncreasingDigits(self, N: int) -> int:
        # 将整数转换为字符串
        strNum = str(N)
        # flag用来标记赋值9从哪里开始
        # 设置为字符串长度，为了防止第二个for循环在flag没有被赋值的情况下执行
        flag = len(strNum)
        
        # 从右往左遍历字符串
        for i in range(len(strNum) - 1, 0, -1):
            # 如果当前字符比前一个字符小，说明需要修改前一个字符
            if strNum[i - 1] > strNum[i]:
                flag = i  # 更新flag的值，记录需要修改的位置
                # 将前一个字符减1，以保证递增性质
                strNum = strNum[:i - 1] + str(int(strNum[i - 1]) - 1) + strNum[i:]
        
        # 将flag位置及之后的字符都修改为9，以保证最大的递增数字
        strNum = strNum[:flag] + "9" * (len(strNum) - flag)
        
        # 将最终的字符串转换回整数并返回
        return int(strNum)
```



### 1121 - 监控二叉树<a id="p1121"></a>

#### 问题

给定一个二叉树，我们在树的节点上安装摄像头。

节点上的每个摄影头都可以监视**其父对象、自身及其直接子对象。**

计算监控树的所有节点所需的最小摄像头数量。

 

**示例 1：**

![img](./assets/bst_cameras_01.png)

```
输入：[0,0,null,0,0]
输出：1
解释：如图所示，一台摄像头足以监控所有节点。
```

**示例 2：**

![img](./assets/bst_cameras_02.png)

```
输入：[0,0,null,0,null,0,null,null,0]
输出：2
解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。
```



#### 解法

自上而下判断...

```python
class Solution:
         # Greedy Algo:
        # 从下往上安装摄像头：跳过leaves这样安装数量最少，局部最优 -> 全局最优
        # 先给leaves的父节点安装，然后每隔两层节点安装一个摄像头，直到Head
        # 0: 该节点未覆盖
        # 1: 该节点有摄像头
        # 2: 该节点有覆盖
    def minCameraCover(self, root: TreeNode) -> int:
        # 定义递归函数
        result = [0]  # 用于记录摄像头的安装数量
        if self.traversal(root, result) == 0:
            result[0] += 1

        return result[0]

        
    def traversal(self, cur: TreeNode, result: List[int]) -> int:
        if not cur:
            return 2

        left = self.traversal(cur.left, result)
        right = self.traversal(cur.right, result)

        # 情况1: 左右节点都有覆盖
        if left == 2 and right == 2:
            return 0

        # 情况2:
        # left == 0 && right == 0 左右节点无覆盖
        # left == 1 && right == 0 左节点有摄像头，右节点无覆盖
        # left == 0 && right == 1 左节点无覆盖，右节点有摄像头
        # left == 0 && right == 2 左节点无覆盖，右节点覆盖
        # left == 2 && right == 0 左节点覆盖，右节点无覆盖
        if left == 0 or right == 0:
            result[0] += 1
            return 1

        # 情况3:
        # left == 1 && right == 2 左节点有摄像头，右节点有覆盖
        # left == 2 && right == 1 左节点有覆盖，右节点有摄像头
        # left == 1 && right == 1 左右节点都有摄像头
        if left == 1 or right == 1:
            return 2
```



### 1122 - 斐波那契数列<a id="p1122"></a>

#### 问题

**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：

```
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
```

给定 `n` ，请计算 `F(n)` 。

 

**示例 1：**

```
输入：n = 2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1
```

**示例 2：**

```
输入：n = 3
输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2
```

**示例 3：**

```
输入：n = 4
输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3
```

 

#### 解法

使用数组存储斐波那契数列，注意处理n小于2的情况

```python
class Solution:
    def fib(self, n: int) -> int:
        if n < 2:
            return n
        fib = [0] * (n + 1)
        fib[1] = 1
        for i in range(2, n + 1):
            fib[i] = fib[i - 2] + fib[i - 1]
        return fib[-1]
```

不使用数组存储斐波那契数列，直接计算

```python
class Solution:
    def fib(self, n: int) -> int:
        a, b, c = 0, 1, 0
        if n < 2:
            return n
        for i in range(2, n + 1):
            c = a + b
            a, b = b, c
        return c
```



### 1123 - 使用最小花费爬楼梯<a id="p1123"></a>

#### 问题

给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

 

**示例 1：**

```
输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。
```

**示例 2：**

```
输入：cost = [1,100,1,1,1,100,1,1,100,1]
输出：6
解释：你将从下标为 0 的台阶开始。
- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
- 支付 1 ，向上爬一个台阶，到达楼梯顶部。
总花费为 6 。
```

 

#### 解法

使用dp记录到当前楼层的最小花费

```python
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        # dp 记录到当前的最低消费
        dp = [0] * (len(cost) + 1)
        dp[0], dp[1] = 0, 0
        for i in range(2, len(cost) + 1):
            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])
        return dp[-1]
```



### 1124 - 不同路径<a id="p1124"></a>

#### 问题

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

 

**示例 1：**

![img](./assets/1697422740-adxmsI-image.png)

```
输入：m = 3, n = 7
输出：28
```

**示例 2：**

```
输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
```

**示例 3：**

```
输入：m = 7, n = 3
输出：28
```

**示例 4：**

```
输入：m = 3, n = 3
输出：6
```

 

#### 解法

数学计算方法

```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # 数学计算
        sum_index = m + n - 2
        up, down = 1, 1
        for i in range(m - 1):
            up *= (sum_index - i)
        for i in range(1, m):
            down *= i
        return up // down
```

动态规划

```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # 创建一个二维列表用于存储唯一路径数
        dp = [[0] * n for _ in range(m)]
        
        # 设置第一行和第一列的基本情况
        for i in range(m):
            dp[i][0] = 1
        for j in range(n):
            dp[0][j] = 1
        
        # 计算每个单元格的唯一路径数
        for i in range(1, m):
            for j in range(1, n):
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        
        # 返回右下角单元格的唯一路径数
        return dp[m - 1][n - 1]
```



### 1125 - 不同路径 II<a id="p1125"></a>

#### 问题

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。

 

**示例 1：**

![img](./assets/robot1.jpg)

```
输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
```

**示例 2：**

![img](./assets/robot2.jpg)

```
输入：obstacleGrid = [[0,1],[0,0]]
输出：1
```

 

#### 解法

注意避障即可。

```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        dp = [[0] * len(obstacleGrid[0]) for _ in range(len(obstacleGrid))]

        for i in range(len(obstacleGrid[0])):
            if obstacleGrid[0][i] == 1:
                break
            dp[0][i] = 1
        
        for i in range(len(obstacleGrid)):
            if obstacleGrid[i][0] == 1:
                break
            dp[i][0] = 1
        
        for i in range(1, len(obstacleGrid)):
            for j in range(1, len(obstacleGrid[0])):
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1] if obstacleGrid[i][j] != 1 else 0
        
        return dp[-1][-1]
```



### 1126 - 整数拆分<a id="p1126"></a>

#### 问题

给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。

返回 *你可以获得的最大乘积* 。

 

**示例 1:**

```
输入: n = 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
```

**示例 2:**

```
输入: n = 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```

 

#### 解法

经过观察发现，当分解出的因数为3时，可以得到最大乘积，所以对应处理即可。(经过数学验证)

```python
class Solution:
    def integerBreak(self, n: int) -> int:
        # 分为3则结果乘积最大
        if n < 4:
            return n - 1
        if n % 3 == 1:
            result = 4
            n -= 4
        elif n % 3 == 2:
            result = 2
            n -= 2
        else:
            result = 1
        while n > 0:
                result *= 3
                n -= 3
        return result
```

动态规划：dp数组存储每个下标的最大乘积，而对于每次选择最大乘积时，只需要再套一层循环即可。内部包含了两个整数相乘和因数和dp数组相乘。

```python
class Solution:
    def integerBreak(self, n: int) -> int:
        dp = [0] * (n + 1)
        dp[2] = 1

        for i in range(2, n + 1):
            for j in range(1, i // 2 + 1):
                dp[i] = max(dp[i], (i - j) * j, dp[i - j] * j)

        return dp[-1]
```



### 1127 - 不同的二叉搜索树<a id="p1127"></a>

#### 问题

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg)

```
输入：n = 3
输出：5
```

**示例 2：**

```
输入：n = 1
输出：1
```

 

#### 解法

根据树的形状进行判断，则dp公式可推导。

```python
class Solution:
    def numTrees(self, n: int) -> int:
        dp = [0] * (n + 1)
        if n < 3:
            return n
        dp[0] = 1
        dp[1] = 1
        dp[2] = 2
        # 假设节点值
        for i in range(3, n + 1):
            for j in range(1, i + 1):
                dp[i] += dp[j - 1] * dp[i - j]
        return dp[-1]
```

这个速度较快，原因可能在于：直接操作列表会拖慢速度，不如直接操作一次的快。

```python
class Solution:
    def numTrees(self, n: int) -> int:
        dp = [-1 for i in range(n+1)]
        dp[0] = 1
        dp[1] = 1

        for r in range(2, n+1):
            res = 0
            for i in range(r):
                left = dp[i]
                right = dp[r-1-i]
                res += left * right

            dp[r] = res

        return dp[n]
```



### 3003 - 01背包问题<a id="p3003"></a>

#### 问题

###### 题目描述

小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。他需要带一些研究材料，但是他的行李箱空间有限。这些研究材料包括实验设备、文献资料和实验样本等等，它们各自占据不同的空间，并且具有不同的价值。 

小明的行李空间为 N，问小明应该如何抉择，才能携带最大价值的研究材料，每种研究材料只能选择一次，并且只有选与不选两种选择，不能进行切割。

###### 输入描述

第一行包含两个正整数，第一个整数 M 代表研究材料的种类，第二个正整数 N，代表小明的行李空间。

第二行包含 M 个正整数，代表每种研究材料的所占空间。 

第三行包含 M 个正整数，代表每种研究材料的价值。

###### 输出描述

输出一个整数，代表小明能够携带的研究材料的最大价值。

###### 输入示例

```
6 1
2 2 3 1 5 2
2 3 1 5 4 3
```

###### 输出示例

```
5
```



#### 解法

对于本题而言，建立二维的dp列表：

![动态规划-背包问题1](./assets/20210110103003361.png)

dp\[i][j]所表达的含义即：在包含了[0,i]的物品里，所占用的空间为j时，背包的最大价值。

对于列表的更新：首先要明确：该物品有存与不存两个状态，且只有在有剩余空间的情况下才能存储，那么对于某个dp\[i][j]而言，更新它的值为要么不添加该物品，则最大价值dp\[i][j] = dp\[i - 1][j]，要么就是有剩余空间的情况下，它的最大价值可能为dp\[i - 1][j - Space[i]] + Value[i]，最终最后的元素就是背包的最大价值。

```Python
M, N = map(int, input().split())

Space = [int(i) for i in input().split()]
Value = [int(i) for i in input().split()]

dp = [[0] * (N + 1) for _ in range(M)]

# 初始化dp数组
for i in range(N + 1):
    dp[0][i] = Value[0] if Space[0] <= i else 0

for i in range(M):
    dp[i][0] = Value[i] if Space[i] == 0 else 0

for i in range(1, M):
    for j in range(1, N + 1):
        if j >= Space[i]:
            # 放或不放的问题，如果放了就需要将当前的价值重新计算，并取组大致
            dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - Space[i]] + Value[i])
        else:
            dp[i][j] = dp[i - 1][j]

print(dp[-1][-1])
```

使用一维数组进行简化：

内层循环进行倒序遍历的原因：因为dp\[i][j]的判断是基于dp\[i - 1][j]的，如果使用一维数组进行正序遍历，那么会导致当前值被覆盖，进而计算出错误的结果。

当然，也进行了部分优化，如倒序遍历只需要遍历到Space[i]，因为再往前遍历背包的容量是不够的。

```python
M, N = map(int, input().split())

Space = [int(i) for i in input().split()]
Value = [int(i) for i in input().split()]

dp = [0] * (N + 1)

for i in range(M):
    for j in range(N, Space[i] - 1, -1):
        if j >= Space[i]:
            dp[j] = max(dp[j], dp[j - Space[i]] + Value[i])

print(dp[-1])
```



### 1128 - 分割等和子集<a id="p1128"></a>

#### 问题

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

 

**示例 1：**

```
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```

**示例 2：**

```
输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
```

 

#### 解法

01背包问题，倒序遍历

主要在于思想，学会问题转换

```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        if sum(nums) % 2:
            return False

        target = sum(nums) // 2
        dp = [0] * (target + 1)
        for num in nums:
            for i in range(target, num - 1, -1):
                dp[i] = max(dp[i], dp[i - num] + num)
            # 提前返回结果
            if dp[-1] == target:
                return True

        return False
```

此题尚有位运算的解法，速度很快，现在不学。



### 1129 - 最后一块石头的重量 II<a id="p1129"></a>

#### 问题

有一堆石头，用整数数组 `stones` 表示。其中 `stones[i]` 表示第 `i` 块石头的重量。

每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：

- 如果 `x == y`，那么两块石头都会被完全粉碎；
- 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。

最后，**最多只会剩下一块** 石头。返回此石头 **最小的可能重量** 。如果没有石头剩下，就返回 `0`。

 

**示例 1：**

```
输入：stones = [2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
```

**示例 2：**

```
输入：stones = [31,26,33,21,40]
输出：5
```

 

#### 解法

问题转换为求最接近一半质量的质量多大，本质上也是01背包问题。最终的结果就是用另一半的质量减去所求的接近一半质量的质量。

```python
class Solution:
    def lastStoneWeightII(self, stones: List[int]) -> int:
        dp = [0] * 15001
        total_sum = sum(stones)
        target = total_sum // 2

        for stone in stones:  # 遍历物品
            for j in range(target, stone - 1, -1):  # 遍历背包
                dp[j] = max(dp[j], dp[j - stone] + stone)

        return total_sum - dp[target] - dp[target]
```



### 1130 - 目标和<a id="p1130"></a>

#### 问题

给你一个非负整数数组 `nums` 和一个整数 `target` 。

向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：

- 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。

返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。

 

**示例 1：**

```
输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
```

**示例 2：**

```
输入：nums = [1], target = 1
输出：1
```



#### 解法

回溯，已验证超时。

```python
class Solution:
    def breaktrack(self, result, temp, Index, nums, target):
        if Index == len(nums) and temp == target:
            result.append(result[-1] + 1)
        elif Index < len(nums):
            self.breaktrack(result, temp + nums[Index], Index + 1, nums, target)
            self.breaktrack(result, temp - nums[Index], Index + 1, nums, target)
        else:
            return
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        # 尝试回溯
        result = [0]
        self.breaktrack(result, 0, 0, nums, target)
        return result[-1]
```

动态规划，数组dp内部存储的是当背包容量为下标i时，有几种方法填满背包。

```python
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        # 根据数学原理推算，实际上所求是：部分数字为加法，部分数字为减法
        # 而且双方和为sum，那么是否存在这么一个加法使得所求target存在呢？
        # 这个所求的数字不能是浮点数，因为nums数组中全为整数，所以不可能存在
        if (target + sum(nums)) % 2:
            return 0
        sum_of_nums = sum(map(abs, nums))
        if sum_of_nums < abs(target):
            return 0
        target_sum = (target + sum_of_nums) // 2
        dp = [0] * (target_sum + 1)
        dp[0] = 1
        for num in nums:
            for j in range(target_sum, num - 1, -1):
                dp[j] += dp[j - num]
        return dp[target_sum]
```



### 1131 - 一和零<a id="p1131"></a>

#### 问题

给你一个二进制字符串数组 `strs` 和两个整数 `m` 和 `n` 。

请你找出并返回 `strs` 的最大子集的长度，该子集中 **最多** 有 `m` 个 `0` 和 `n` 个 `1` 。

如果 `x` 的所有元素也是 `y` 的元素，集合 `x` 是集合 `y` 的 **子集** 。

 

**示例 1：**

```
输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。
```

**示例 2：**

```
输入：strs = ["10", "0", "1"], m = 1, n = 1
输出：2
解释：最大的子集是 {"0", "1"} ，所以答案是 2 。
```

 

#### 解法

注意对于01背包的二维数组，也要注意从后遍历的问题：本题遇见的问题就是背包有两个维度，这导致双层循环均需要倒序进行。

```python
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        # 使用二维数组，dp[m][n]表达在最多容纳m个0和n个1的情况下子集长度为多少
        dp = [[0] * (m + 1) for _ in range(n + 1)]
        for char in strs:
            # 计算出当前字符串包含了多少个字符串
            numZero = char.count("0")
            numOne = len(char) - numZero
            for i in range(n, numOne - 1, -1):
                for j in range(m, numZero - 1, -1):
                    dp[i][j] = max(dp[i][j], dp[i - numOne][j - numZero] + 1)
        return dp[-1][-1]
```



### 3004 - 完全背包问题<a id="p3004"></a>

#### 问题

小明的行李箱所能承担的总重量为 N，问小明应该如何抉择，才能携带最大价值的研究材料，每种研究材料可以选择无数次，并且可以重复选择。

###### 输入描述

第一行包含两个整数，N，V，分别表示研究材料的种类和行李空间 

接下来包含 N 行，每行两个整数 wi 和 vi，代表第 i 种研究材料的重量和价值

###### 输出描述

输出一个整数，表示最大价值。

###### 输入示例

```
4 5
1 2
2 4
3 4
4 5
```

###### 输出示例

```
10
```



#### 解法

完全背包和01背包的最大区别在于完全背包的物品可以重复利用。

```python
N, V = map(int, input().split())
WV = []
[WV.append(list(map(int, input().split()))) for _ in range(N)]

dp = [0] * (V + 1)

for i in range(N):
    for j in range(V + 1):
        if WV[i][0] <= j:
            dp[j] = max(dp[j], dp[j - WV[i][0]] + WV[i][1])

print(dp[-1])
```



### 1132 - 零钱兑换 II<a id="p1132"></a>

#### 问题

给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。

 

**示例 1：**

```
输入：amount = 5, coins = [1, 2, 5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```

**示例 2：**

```
输入：amount = 3, coins = [2]
输出：0
解释：只用面额 2 的硬币不能凑成总金额 3 。
```

**示例 3：**

```
输入：amount = 10, coins = [10] 
输出：1
```

 

#### 解法

完全背包问题，对于方法数就应该递增。

```python
class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        dp = [0] * (amount + 1)
        dp[0] = 1
        for coin in coins:
            for i in range(coin, len(dp)):
                dp[i] += dp[i - coin]
        return dp[-1]
```



### 1133 - 组合总数 IV<a id="p1133"></a>

#### 问题

给你一个由 **不同** 整数组成的数组 `nums` ，和一个目标整数 `target` 。请你从 `nums` 中找出并返回总和为 `target` 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

 

**示例 1：**

```
输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。
```

**示例 2：**

```
输入：nums = [9], target = 3
输出：0
```

 

#### 解法

需要注意的是：对于求组合数而言，需要外层遍历物品，内层遍历背包；而对于求排列数而言，就需要外层遍历背包，内层遍历物品。

```python
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        dp = [0] * (target + 1)
        dp[0] = 1
        for i in range(1, target + 1):  # 遍历背包
            for num in nums:  # 遍历物品
                if i - num >= 0:
                    dp[i] += dp[i - num]
        return dp[-1]
```



### 3005 - 爬楼梯 II<a id="p3005"></a>

#### 问题

###### 输入描述

输入共一行，包含两个正整数，分别表示n, m

###### 输出描述

输出一个整数，表示爬到楼顶的方法数。

###### 输入示例

```
3 2
```

###### 输出示例

```
3
```



#### 解法

完全背包

```python
n, m = map(int, input().split())

# 爬上i阶台阶有dp[i]方法
dp = [0] * (n + 1)

dp[0] = 1
for i in range(1, n + 1):
    for j in range(1, m + 1):
        if i - j >= 0:
            dp[i] += dp[i - j]

print(dp[-1])
```



### 1134 - 零钱兑换<a id="p1134"></a>

#### 问题

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。

 

**示例 1：**

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

**示例 2：**

```
输入：coins = [2], amount = 3
输出：-1
```

**示例 3：**

```
输入：coins = [1], amount = 0
输出：0
```

 

#### 解法

如果不能拼凑成当前的金额，那么其需要的硬币数就是最大值。

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        # dp数组表示了在凑齐i金额的情况下使用的最小硬币个数
        dp = [float('inf')] * (amount + 1)  # 创建动态规划数组，初始值为正无穷大
        dp[0] = 0  # 初始化背包容量为0时的最小硬币数量为0

        for i in range(1, amount + 1):
            for coin in coins:
                if i - coin >= 0 and dp[i - coin] != float('inf'):  # 如果dp[i - coins[j]]不是初始值，则进行状态转移
                    dp[i] = min(dp[i], dp[i - coin] + 1)
        
        return dp[-1] if dp[-1] != float('inf') else -1
```



### 1135 - 单词拆分<a id="p1135"></a>

#### 问题

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 `s` 则返回 `true`。

**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

 

**示例 1：**

```
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。
```

**示例 2：**

```
输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。
     注意，你可以重复使用字典中的单词。
```

**示例 3：**

```
输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false
```

 

#### 解法

回溯算法，已经超时，即便通过辅助列表优化也超时(某个索引后无法拆分)

```python
class Solution:
    def breaktrack(self, wordset, startIndex, s):
        # 传递来的索引已经越界，说明拆分完毕
        if startIndex >= len(s):
            return True

        # 拆分
        for i in range(startIndex, len(s)):
            word = s[startIndex:i + 1]
            # 如果能完全拆分
            if word in wordset and self.breaktrack(wordset, i + 1, s):
                return True

        # 无法拆分
        return False

    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        # 回溯，将list转为Set提高查找效率
        wordset = set(wordDict)
        return self.breaktrack(wordset, 0, s)
```

动态规划写法：dp数组表示自当前索引以前的字符串可以拆分成单词，如果为True说明自此以前的均可拆分。

至于像s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]这类用例是如何判断的：实际上冲突位于d，因为sand和dog冲突，其实dp[i]也表达了索引为i的首字母是否可用，如果选择了sand，那么d就不可以再使用了，所以会返回False。

```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        # dp数组用来表述当前索引以前的字符串是否可以分割成单词
        wordset = set(wordDict)
        dp = [False] * (len(s) + 1)
        dp[0] = True

        for i in range(1, len(s) + 1):
            for j in range(i):
                if s[j:i] in wordset and dp[j]:
                    dp[i] = True
                    break
        return dp[len(s)]
```



### 1136 - 打家劫舍<a id="p1136"></a>

#### 问题

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

 

**示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 2：**

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

 

#### 解法

实际上本题想法十分简单，就是对于dp[i]而言，其只有两个想法，要么偷要么不偷，如果偷的话：就只能考虑dp[i - 2]，不能考虑dp[i - 1]；如果不偷，因为它本质之上是不会偷i的，所以它的最大值就是dp[i - 1]。

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) < 2:
            return nums[0]
        # dp表示当前索引下的最高金额
        dp = [0] * len(nums)
        dp[0], dp[1] = nums[0], max(nums[0], nums[1])
        # 递推公式为：dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])
        for i in range(2, len(nums)):
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])
        return dp[-1]
```



### 1137 - 打家劫舍 II<a id="p1137"></a>

#### 问题

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 **围成一圈** ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警** 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **在不触动警报装置的情况下** ，今晚能够偷窃到的最高金额。

 

**示例 1：**

```
输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
```

**示例 2：**

```
输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 3：**

```
输入：nums = [1,2,3]
输出：3
```

 

#### 解法

该问题是将初始问题升级为环，实际上转化思想就是偷首还是偷尾的问题。

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums)==1:
            return nums[0]
        if len(nums)==2 or len(nums)==3:
            return max(nums)

        dp = [0] * len(nums)
        dp[0], dp[1] = nums[0], max(nums[0], nums[1])

        for i in range(2, len(nums) - 1):
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])
        val1 = dp[-2]

        dp[1], dp[2] = nums[1], max(nums[1], nums[2])
        for i in range(3, len(nums)):
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])
        val2 = dp[-1]

        return max(val1, val2)
```



### 1138 - 打家劫舍 III<a id="p1138"></a>

#### 问题

小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 `root` 。

除了 `root` 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 **两个直接相连的房子在同一天晚上被打劫** ，房屋将自动报警。

给定二叉树的 `root` 。返回 ***在不触动警报的情况下** ，小偷能够盗取的最高金额* 。

 

**示例 1:**

![img](./assets/rob1-tree.jpg)

```
输入: root = [3,2,3,null,3,null,1]
输出: 7 
解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7
```

**示例 2:**

![img](./assets/rob2-tree.jpg)

```
输入: root = [3,4,5,1,3,null,1]
输出: 9
解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9
```

 

#### 解法

直接递归计算，每次选择是否偷当前节点然后选取最大值。

已验证超时

```python
class Solution:
    def rob(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        if not root.left and not root.right:
            return root.val
            
        # 偷当前节点情况下的值
        val1 = root.val
        # 如果有孩子节点，就偷孩子节点的孩子节点
        if root.left:
            val1 += self.rob(root.left.left) + self.rob(root.left.right)
        if root.right:
            val1 += self.rob(root.right.left) + self.rob(root.right.right)
        
        # 不偷当前节点情况下的值
        val2 = self.rob(root.left) + self.rob(root.right)
        return max(val1, val2)
```

对以上算法进行优化：进行记忆化搜索，将已经计算过的节点加入字典即可。

```python
class Solution:
    memory = {}
    def rob(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        if not root.left and not root.right:
            return root.val

        # 记忆化搜索优化：如果当前节点已经被计算过，就直接返回值
        if self.memory.get(root):
            return self.memory[root]

        # 偷当前节点情况下的值
        val1 = root.val
        # 如果有孩子节点，就偷孩子节点的孩子节点
        if root.left:
            val1 += self.rob(root.left.left) + self.rob(root.left.right)
        if root.right:
            val1 += self.rob(root.right.left) + self.rob(root.right.right)
        
        # 不偷当前节点情况下的值
        val2 = self.rob(root.left) + self.rob(root.right)

        # 将当前节点计算得到的值加入记忆字典
        self.memory[root] = max(val1, val2)
        return max(val1, val2)
```

动态规划：利用长度为2的dp数组：dp[0]代表了不偷当前节点所获得的最大值，dp[1]代表偷当前节点获取到的最大值，配合递归即可求解。

```python
class Solution:
    def traversal(self, root):
        if not root:
            return [0, 0]

        left = self.traversal(root.left)
        right = self.traversal(root.right)

        # 不偷
        val1 = max(left) + max(right)

        # 偷
        val2 = root.val + left[0] + right[0]

        return [val1, val2]
    def rob(self, root: Optional[TreeNode]) -> int:
        # dp数组代表是否偷当前节点，0代表不偷当前节点得到的最大值，1代表偷
        dp = self.traversal(root)
        return max(dp)
```



### 1139 - 买卖股票的最佳时机 III<a id="p1139"></a>

#### 问题

给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

**示例 1:**

```
输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
```

**示例 2：**

```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3：**

```
输入：prices = [7,6,4,3,1] 
输出：0 
解释：在这个情况下, 没有交易完成, 所以最大利润为 0。
```

**示例 4：**

```
输入：prices = [1]
输出：0
```

 

#### 解法

裁缝版：先计算第一次获取的最大利润，再将买入-卖出的区间段删去，计算第二次获取的最大利润即可。该方法问题在于无法计算总的最大利润：因为每次计算都是最大利润，这导致可以在第一次计算的过程中虽然能取得了最大值，但是整体并没有取到最大值，如下测试用例：

> [6,1,3,2,4,7]
>
> 预期结果：7
>
> 实际结果：6

```python
# 裁缝版：无法通过，但是测试用例通过80%
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # 先计算第一次的收入
        min_price = float('inf')
        val1 = 0
        startindex, endindex = 0, 0
        for i in range(len(prices)):
            if prices[i] <= min_price:
                min_price = prices[i]
            if prices[i] - min_price >= val1:
                val1 = prices[i] - min_price
                endindex = i

        for i in range(endindex, -1, -1):
            if prices[endindex] - prices[i] == val1:
                startindex = i

        if startindex >= endindex:
            return val1
        # 将原本的区间截去
        new_prices = prices[:startindex] + prices[endindex + 1:]
        if not new_prices:
            return val1

        min_price = float('inf')
        val2 = 0
        for i in range(len(new_prices)):
            min_price = min(new_prices[i], min_price)
            val2 = max(new_prices[i] - min_price, val2)
        return val1 + val2

```

动态规划：

​		该方法设计的dp数组的含义为：对于dp\[i][j]：表示在第i天处于j状态下持有的最多现金；有如下四种状态：1.第一次持有股票 2.第一次不持有股票 3.第二次持有股票 4.第二次不持有股票。

​		这其中需要注意的地方：对于计算第一次持有股票时，其起始利润应从dp\[i - 1][0]计算而不是dp\[i - 1][2]。

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # 对于dp[i][j]：表示在第i天处于j状态下持有的最多现金
        # 0:无操作 1:第一次持有股票 2：第一次不持有股票 3：第二次持有股票 4：第二次不持有股票
        dp = [[0] * 5 for _ in range(len(prices))]
        dp[0] = [0, -prices[0], 0, -prices[0], 0]
        for i in range(1, len(prices)):
            # 第一次持有股票：昨天持有或是今天购入
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])
            # 第一次不持有股票：没买或者今天卖出
            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i])
            # 第二次持有股票：
            dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i])
            # 第二次不持有股票：一直没买或者今日卖出
            dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i])
        return dp[-1][-1]
```



### 1140 - 买卖股票的最佳时机 IV<a id="p1140"></a>

#### 问题

给你一个整数数组 `prices` 和一个整数 `k` ，其中 `prices[i]` 是某支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 `k` 笔交易。也就是说，你最多可以买 `k` 次，卖 `k` 次。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

**示例 1：**

```
输入：k = 2, prices = [2,4,1]
输出：2
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
```

**示例 2：**

```
输入：k = 2, prices = [3,2,6,5,0,3]
输出：7
解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。
```

 

#### 解法

动态规划：对于上题而言，可以发现规律：对于第i次买入或者卖出的价格取决于第i- 1次买入或卖出的价格，所以只要对次数进行控制即可。

```python
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        dp = [[0] * ((k * 2) + 1) for _ in range(len(prices))]
        for i in range(1, (k * 2) + 1, 2):
            dp[0][i] = -prices[0]

        for i in range(1, len(prices)):
            for j in range(1, (k * 2) + 1, 2):
                # 第i次持有
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] - prices[i])
                # 第i次不持有
                dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] + prices[i])

        return dp[-1][-1]
```



### 1141 - 买卖股票的最佳时机含冷冻期<a id="p1141"></a>

#### 问题

给定一个整数数组`prices`，其中第 `prices[i]` 表示第 `*i*` 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

**示例 1:**

```
输入: prices = [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

**示例 2:**

```
输入: prices = [1]
输出: 0
```

 

#### 解法

动态规划：细分为四个状态，分别为：

> 状态一：持有股票状态（今天买入股票，或者是之前就买入了股票然后没有操作，一直持有）
>
> 不持有股票状态，这里就有两种卖出股票状态
>
> 状态二：保持卖出股票的状态（两天前就卖出了股票，度过一天冷冻期。或者是前一天就是卖出股票状态，一直没操作）
>
> 状态三：今天卖出股票
>
> 状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！

实际上不太好理解。

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # 四个状态：0：持有 1：未持有且是因为昨天为冷冻期 2：未持有，今日卖出 3：冷冻期
        dp = [[0] * 4 for _ in range(len(prices))]

        dp[0] = [-prices[0], 0, 0, 0]

        for i in range(1, len(prices)):
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][3] - prices[i], dp[i - 1][1] - prices[i])
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][3])
            dp[i][2] = dp[i - 1][0] + prices[i]
            dp[i][3] = dp[i - 1][2]
        
        return max(dp[-1])
```

分为三个状态，将状态二和状态四合并，反而好理解一些。

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # 三个状态：0：持有 1：不持有且处于冷冻期 2：不持有且不处于冷冻期
        dp = [[0] * 3 for _ in range(len(prices))]

        dp[0] = [-prices[0], 0, 0]

        for i in range(1, len(prices)):
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][2] - prices[i])
            dp[i][1] = dp[i - 1][0] + prices[i]
            # 不买或者刚从冷冻期脱离
            dp[i][2] = max(dp[i - 1][1], dp[i - 1][2])
        
        return max(dp[-1])
```



### 1142 - 或值至少K的最短子数组 I<a id="p1142"></a>

#### 问题

给你一个 **非负** 整数数组 `nums` 和一个整数 `k` 。

如果一个数组中所有元素的按位或运算 `OR` 的值 **至少** 为 `k` ，那么我们称这个数组是 **特别的** 。

请你返回 `nums` 中 **最短特别非空** 

子数组

的长度，如果特别子数组不存在，那么返回 `-1` 。



 

**示例 1：**

**输入：**nums = [1,2,3], k = 2

**输出：**1

**解释：**

子数组 `[3]` 的按位 `OR` 值为 `3` ，所以我们返回 `1` 。

**示例 2：**

**输入：**nums = [2,1,8], k = 10

**输出：**3

**解释：**

子数组 `[2,1,8]` 的按位 `OR` 值为 `11` ，所以我们返回 `3` 。

**示例 3：**

**输入：**nums = [1,2], k = 0

**输出：**1

**解释：**

子数组 `[1]` 的按位 `OR` 值为 `1` ，所以我们返回 `1` 。

 

- `1 <= nums.length <= 50`
- `0 <= nums[i] <= 50`
- `0 <= k < 64`



#### 解法

直接暴力解法，仅针对于此种数据量较少的

```python
class Solution:
    def minimumSubarrayLength(self, nums: List[int], k: int) -> int:
        minnum = float('inf')
        # 每次截取的长度
        for i in range(1, len(nums) + 1):
            # 每次初始的长度
            for j in range(len(nums) - i + 1):
                new_nums = nums[j:j + i]
                start = 0
                for num in new_nums:
                    start = start | num
                if start >= k:
                    minnum = min(minnum, i)
        return minnum if minnum != float('inf') else -1
```



### 1143 - 或值至少为K的最短子数组 II<a id="p1143"></a>

#### 问题

与上题相同，但是

- `1 <= nums.length <= 2 * 105`
- `0 <= nums[i] <= 109`
- `0 <= k <= 109`



#### 解法

回溯：对于子数组而言，和子序列的区别在于子数组必须是连续的而子序列则不必是连续的。

目前通过测试用例713/716

```python
# 枚举
class Solution:
    def breaktrack(self, result, k, nownum, startIndex, nums, lenth):   
        print(startIndex)    
        for i in range(startIndex - 1, -1, -1):
            nownum = nownum | nums[i]
            lenth += 1
            if nownum >= k:
                result = min(result, lenth)
        return result
            
    def minimumSubarrayLength(self, nums: List[int], k: int) -> int:
        result = set()
        min_result = float('inf')

        for i in range(len(nums) - 1, -1, -1):
            if nums[i] >= k:
                return 1
            min_result = min(self.breaktrack(min_result, k, nums[i], i, nums, 1), min_result)
        return min_result if min_result != float('inf') else -1
```

滑动窗口法：使用滑动窗口进行计算，一旦遇到符合条件的值就会更新滑动窗口的范围，即从当前右指针发出临时指针，直到当前的值再次符合条件，将临时指针作为左指针。

该方法通过测试用例715/716

```python
class Solution:
    def minimumSubarrayLength(self, nums: List[int], k: int) -> int:
        # 双指针 滑动窗口
        left, right = 0, 0
        val, result = 0, float('inf')
        while len(nums) > right:
            val = val | nums[right]
            right += 1
            if val >= k:
                result = min(result, right - left)
                # 左指针移动
                left = right - 1
                val = nums[left]
                while val < k:
                    left -= 1
                    val = val | nums[left]
                result = min(result, right - left)
                
        return result if result != float("inf") else -1
```

更优化的方法由于理解问题不再概述。



### 1144 - 得到更多分数的最少关卡数<a id="p1144"></a>

#### 问题

给你一个长度为 `n` 的二进制数组 `possible` 。

莉叩酱和冬坂五百里正在玩一个有 `n` 个关卡的游戏，游戏中有一些关卡是 **困难** 模式，其他的关卡是 **简单** 模式。如果 `possible[i] == 0` ，那么第 `i` 个关卡是 **困难** 模式。一个玩家通过一个简单模式的关卡可以获得 `1` 分，通过困难模式的关卡将失去 `1` 分。

游戏的一开始，莉叩酱将从第 `0` 级开始 **按顺序** 完成一些关卡，然后冬坂五百里会完成剩下的所有关卡。

假设两名玩家都采取最优策略，目的是 **最大化** 自己的得分，莉叩酱想知道自己 **最少** 需要完成多少个关卡，才能获得比冬坂五百里更多的分数。

请你返回莉叩酱获得比冬坂五百里更多的分数所需要完成的 **最少** 关卡数目，如果 **无法** 达成，那么返回 `-1` 。

**注意**，每个玩家都至少需要完成 `1` 个关卡。

 

**示例 1：**

> **输入：**possible = [1,0,1,0]
>
> **输出：**1
>
> **解释：**
>
> 我们来看一下莉叩酱可以完成的关卡数目：
>
> - 如果莉叩酱只完成关卡 0 ，冬坂五百里完成剩下的所有关卡，那么莉叩酱获得 1 分，冬坂五百里获得 -1 + 1 - 1 = -1 分。
> - 如果莉叩酱完成到关卡 1 ，冬坂五百里完成剩下的所有关卡，那么莉叩酱获得 1 - 1 = 0 分，冬坂五百里获得 1 - 1 = 0 分。
> - 如果莉叩酱完成到关卡 2 ，冬坂五百里完成剩下的所有关卡，那么莉叩酱获得 1 - 1 + 1 = 1 分，冬坂五百里获得 -1 分。
>
> 莉叩酱需要完成至少一个关卡获得更多的分数。

**示例 2：**

> **输入：**possible = [1,1,1,1,1]
>
> **输出：**3
>
> **解释：**
>
> 我们来看一下莉叩酱可以完成的关卡数目：
>
> - 如果莉叩酱只完成关卡 0 ，冬坂五百里完成剩下的所有关卡，那么莉叩酱获得 1 分，冬坂五百里获得 4 分。
> - 如果莉叩酱完成到关卡 1 ，冬坂五百里完成剩下的所有关卡，那么莉叩酱获得 2 分，冬坂五百里获得 3 分。
> - 如果莉叩酱完成到关卡 2 ，冬坂五百里完成剩下的所有关卡，那么莉叩酱获得 3 分，冬坂五百里获得 2 分。
> - 如果莉叩酱完成到关卡 3 ，冬坂五百里完成剩下的所有关卡，那么莉叩酱获得 4 分，冬坂五百里获得 1 分。
>
> 莉叩酱需要完成至少三个关卡获得更多的分数。

**示例 3：**

> **输入：**possible = [0,0]
>
> **输出：**-1
>
> **解释：**
>
> 两名玩家只能各完成 1 个关卡，莉叩酱完成关卡 0 得到 -1 分，冬坂五百里完成关卡 1 得到 -1 分。两名玩家得分相同，所以莉叩酱无法得到更多分数。

 

#### 解法

优化：当前得分实际上是1的个数减去0的个数。

不必每次计算当前得分，可以先假设只通过一关，以此类推，只需要进行一次循环即可。

```python
class Solution:
    def minimumLevels(self, possible: List[int]) -> int:
        # 最小完成关数
        val1 = 1 if possible[0] == 1 else -1
        val2 = sum(possible[1:]) * 2 - len(possible[1:])
        for i in range(1, len(possible)):
            # 计算得分
            if val1 > val2:
                return i
            val1 += 1 if possible[i] == 1 else -1
            val2 += -1 if possible[i] == 1 else 1
        return -1
```



### 2001 - 求和<a id="p2001"></a>

#### 问题

##### 题目描述

给定 $n$ 个整数 $a_{1}, a_{2}, \cdots, a_{n}$, 求它们两两相乘再相加的和，即

$$
S=a_{1} \cdot a_{2}+a_{1} \cdot a_{3}+\cdots+a_{1} \cdot a_{n}+a_{2} \cdot a_{3}+\cdots+a_{n-2} \cdot a_{n-1}+a_{n-2} \cdot a_{n}+a_{n-1} \cdot a_{n}
$$

##### 输入格式

输入的第一行包含一个整数 $n$ 。

第二行包含 $n$ 个整数 $a_{1}, a_{2}, \cdots a_{n}$ 。

##### 输出格式

输出一个整数 $S$，表示所求的和。请使用合适的数据类型进行运算。



##### 输入

```
4
1 3 6 9
```

##### 输出

```
117
```



#### 解法

利用数学思想进行计算。

原理：根据公式可推导，每个节点都是乘的以后节点再求和，那么只需要再新建一个列表储存到当前节点的和，最终反转(S - S[i])就是当前节点以后的节点和，最终求和即可。

```python
n = int(input())
nums = [i for i in map(int, input().split())]
result = 0
S = 0
nums2 = [0] * len(nums)

for i in range(len(nums)):
    S += nums[i]
    nums2[i] = S

for i in range(len(nums) - 1):
    result += nums[i] * (S - nums2[i])

print(result)
```



### 1145 -  故障键盘<a id="p1145"></a>

#### 问题

你的笔记本键盘存在故障，每当你在上面输入字符 `'i'` 时，它会反转你所写的字符串。而输入其他字符则可以正常工作。

给你一个下标从 **0** 开始的字符串 `s` ，请你用故障键盘依次输入每个字符。

返回最终笔记本屏幕上输出的字符串。

 

**示例 1：**

```
输入：s = "string"
输出："rtsng"
解释：
输入第 1 个字符后，屏幕上的文本是："s" 。
输入第 2 个字符后，屏幕上的文本是："st" 。
输入第 3 个字符后，屏幕上的文本是："str" 。
因为第 4 个字符是 'i' ，屏幕上的文本被反转，变成 "rts" 。
输入第 5 个字符后，屏幕上的文本是："rtsn" 。
输入第 6 个字符后，屏幕上的文本是： "rtsng" 。
因此，返回 "rtsng" 。
```

**示例 2：**

```
输入：s = "poiinter"
输出："ponter"
解释：
输入第 1 个字符后，屏幕上的文本是："p" 。
输入第 2 个字符后，屏幕上的文本是："po" 。
因为第 3 个字符是 'i' ，屏幕上的文本被反转，变成 "op" 。
因为第 4 个字符是 'i' ，屏幕上的文本被反转，变成 "po" 。
输入第 5 个字符后，屏幕上的文本是："pon" 。
输入第 6 个字符后，屏幕上的文本是："pont" 。
输入第 7 个字符后，屏幕上的文本是："ponte" 。
输入第 8 个字符后，屏幕上的文本是："ponter" 。
因此，返回 "ponter" 。
```

 

#### 解法

```python
class Solution:
    def finalString(self, s: str) -> str:
        res = ""
        for i in s:
            if i == "i":
                res = res[::-1]
                continue
            else:
                res = res + i
        return res
```



### 1146 - 奇偶位数<a id="p1146"></a>

#### 问题

给你一个 **正** 整数 `n` 。

用 `even` 表示在 `n` 的二进制形式（下标从 **0** 开始）中值为 `1` 的偶数下标的个数。

用 `odd` 表示在 `n` 的二进制形式（下标从 **0** 开始）中值为 `1` 的奇数下标的个数。

返回整数数组 `answer` ，其中 `answer = [even, odd]` 。

 

**示例 1：**

```
输入：n = 17
输出：[2,0]
解释：17 的二进制形式是 10001 。 
下标 0 和 下标 4 对应的值为 1 。 
共有 2 个偶数下标，0 个奇数下标。
```

**示例 2：**

```
输入：n = 2
输出：[0,1]
解释：2 的二进制形式是 10 。 
下标 1 对应的值为 1 。 
共有 0 个偶数下标，1 个奇数下标。
```

 

#### 解法

对字符串的处理以及反转

```python
class Solution:
    def evenOddBit(self, n: int) -> List[int]:
        res = [0, 0]
        string = bin(n)[2:][::-1]
        for i in range(len(string)):
            if string[i] == "1":
                if i % 2:
                    res[1] += 1
                else:
                    res[0] += 1
        return res
```



### 1147 - 所有可能的真二叉树<a id="p1147"></a>

#### 问题

给你一个整数 `n` ，请你找出所有可能含 `n` 个节点的 **真二叉树** ，并以列表形式返回。答案中每棵树的每个节点都必须符合 `Node.val == 0` 。

答案的每个元素都是一棵真二叉树的根节点。你可以按 **任意顺序** 返回最终的真二叉树列表**。**

**真二叉树** 是一类二叉树，树中每个节点恰好有 `0` 或 `2` 个子节点。

 

**示例 1：**

![img](./assets/fivetrees.png)

```
输入：n = 7
输出：[[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]
```

**示例 2：**

```
输入：n = 3
输出：[[0,0,0]]
```

 

#### 解法

递归构建满二叉树，每次控制左右结点的数量。

难点在于理解res数组的意义：随着递归深入不容易理解。

```python
class Solution:
    # 子问题：构造一棵满二叉树
    def allPossibleFBT(self, N: int) -> List[TreeNode]:
        res = []
        if N == 1:
            return [TreeNode(0)]
        # 结点个数必须是奇数
        if N % 2 == 0:
            return res
        
        # 左子树分配一个节点
        left_num = 1
        # 右子树可以分配到 N - 1 - 1 = N - 2 个节点
        right_num = N - 2
        
        while right_num > 0:
            # 递归构造左子树
            left_tree = self.allPossibleFBT(left_num)
            # 递归构造右子树
            right_tree = self.allPossibleFBT(right_num)
            # 具体构造过程
            for i in range(len(left_tree)):
                for j in range(len(right_tree)):
                    root = TreeNode(0)
                    root.left = left_tree[i]
                    root.right = right_tree[j]
                    res.append(root)
            left_num += 2
            right_num -= 2
        
        return res
```

动态规划，使用dp数组存储当叶子结点个数为i时的结点列表。

核心代码在于入动态分配左右节点数量，并创建树。

```python
class Solution:
    def allPossibleFBT(self, N: int) -> List[TreeNode]:
        # 最多只会构建二十个结点，可以使用动态规划返回
        dp = [[] for _ in range(11)]
        dp[1] = [TreeNode()]
        if not N % 2:
            return []
        for i in range(2, 11):
            dp[i] = [TreeNode(0, left, right)
                    for j in range(1, i)
                    for left in dp[j]
                    for right in dp[i - j]]
        
        return dp[(N + 1) // 2]
```



### 1148 - 找出克隆二叉树中的相同节点<a id="p1148"></a>

#### 问题

给你两棵二叉树，原始树 `original` 和克隆树 `cloned`，以及一个位于原始树 `original` 中的目标节点 `target`。

其中，克隆树 `cloned` 是原始树 `original` 的一个 **副本** 。

请找出在树 `cloned` 中，与 `target` **相同** 的节点，并返回对该节点的引用（在 C/C++ 等有指针的语言中返回 节点指针，其他语言返回节点本身）。

 

**注意：**你 **不能** 对两棵二叉树，以及 `target` 节点进行更改。**只能** 返回对克隆树 `cloned` 中已有的节点的引用。



**示例 1:**

![img](./assets/e1.png)

```
输入: tree = [7,4,3,null,null,6,19], target = 3
输出: 3
解释: 上图画出了树 original 和 cloned。target 节点在树 original 中，用绿色标记。答案是树 cloned 中的黄颜色的节点（其他示例类似）。
```

**示例 2:**

![img](./assets/e2.png)

```
输入: tree = [7], target =  7
输出: 7
```

**示例 3:**

![img](./assets/e3.png)

```
输入: tree = [8,null,6,null,5,null,4,null,3,null,2,null,1], target = 4
输出: 4
```

 

#### 解法

迭代遍历节点，值相同即返回。

```python
class Solution:
    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:
        # 遍历二叉树，遇到相同节点返回即可。
        from collections import deque
        deque = collections.deque([cloned])
        while deque:
            node = deque.pop()

            if node.val == target.val:
                return node

            if node.left:
                deque.append(node.left)
            if node.right:
                deque.append(node.right)
```



### 1149 - 统计元音字母序列的数目<a id="p1149"></a>

#### 问题

给你一个整数 `n`，请你帮忙统计一下我们可以按下述规则形成多少个长度为 `n` 的字符串：

- 字符串中的每个字符都应当是小写元音字母（`'a'`, `'e'`, `'i'`, `'o'`, `'u'`）
- 每个元音 `'a'` 后面都只能跟着 `'e'`
- 每个元音 `'e'` 后面只能跟着 `'a'` 或者是 `'i'`
- 每个元音 `'i'` 后面 **不能** 再跟着另一个 `'i'`
- 每个元音 `'o'` 后面只能跟着 `'i'` 或者是 `'u'`
- 每个元音 `'u'` 后面只能跟着 `'a'`

由于答案可能会很大，所以请你返回 模 `10^9 + 7` 之后的结果。

 

**示例 1：**

```
输入：n = 1
输出：5
解释：所有可能的字符串分别是："a", "e", "i" , "o" 和 "u"。
```

**示例 2：**

```
输入：n = 2
输出：10
解释：所有可能的字符串分别是："ae", "ea", "ei", "ia", "ie", "io", "iu", "oi", "ou" 和 "ua"。
```

**示例 3：**

```
输入：n = 5
输出：68
```

 

#### 解法

使用动态规划，统计每个元音字母结尾的可能性即可。

```python
class Solution:
    def countVowelPermutation(self, n: int) -> int:
        # 寻找最多的可能，使用动态规划
        # dp 代表以某字母结尾的情况下，最多有多少构成可能
        dp = [1, 1, 1, 1, 1]

        for i in range(1, n):
            last_dp = dp[:]
            dp[0] = (last_dp[1] + last_dp[2] + last_dp[4])
            dp[1] = (last_dp[0] + last_dp[2])
            dp[2] = (last_dp[1] + last_dp[3])
            dp[3] = last_dp[2]
            dp[4] = (last_dp[2] + last_dp[3])

        return sum(dp) % (10 ** 9 + 7)
```



### 1150 - 有向无环图中一个节点的所有祖先<a id="p1150"></a>

#### 问题

给你一个正整数 `n` ，它表示一个 **有向无环图** 中节点的数目，节点编号为 `0` 到 `n - 1` （包括两者）。

给你一个二维整数数组 `edges` ，其中 `edges[i] = [fromi, toi]` 表示图中一条从 `fromi` 到 `toi` 的单向边。

请你返回一个数组 `answer`，其中 `answer[i]`是第 `i` 个节点的所有 **祖先** ，这些祖先节点 **升序** 排序。

如果 `u` 通过一系列边，能够到达 `v` ，那么我们称节点 `u` 是节点 `v` 的 **祖先** 节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2019/12/12/e1.png)

```
输入：n = 8, edgeList = [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]]
输出：[[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]]
解释：
上图为输入所对应的图。
- 节点 0 ，1 和 2 没有任何祖先。
- 节点 3 有 2 个祖先 0 和 1 。
- 节点 4 有 2 个祖先 0 和 2 。
- 节点 5 有 3 个祖先 0 ，1 和 3 。
- 节点 6 有 5 个祖先 0 ，1 ，2 ，3 和 4 。
- 节点 7 有 4 个祖先 0 ，1 ，2 和 3 。
```

**示例 2：**

![img](./assets/e2-1712306442896-3.png)

```
输入：n = 5, edgeList = [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
输出：[[],[0],[0,1],[0,1,2],[0,1,2,3]]
解释：
上图为输入所对应的图。
- 节点 0 没有任何祖先。
- 节点 1 有 1 个祖先 0 。
- 节点 2 有 2 个祖先 0 和 1 。
- 节点 3 有 3 个祖先 0 ，1 和 2 。
- 节点 4 有 4 个祖先 0 ，1 ，2 和 3 。
```



#### 解法

超时暴力解法：先将所有的节点加入到列表中，再统计节点的父节点的祖先。超时

```python
class Solution:
    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:
        result = [[] for _ in range(n)]
        for edge in edges:
            result[edge[1]].append(edge[0])
        for i in range(n):
            if result[i]:
                for j in result[i]:
                    result[i].extend(result[j])
                result[i] = list(set(result[i]))
                result[i].sort()
        return result
```

优化暴力广度优先遍历：

```python
class Solution:
    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:
        def bfs(s: int):
            q = deque([s])
            vis = {s}
            while q:
                i = q.popleft()
                for j in g[i]:
                    if j not in vis:
                        vis.add(j)
                        q.append(j)
                        ans[j].append(s)

        g = defaultdict(list)
        for u, v in edges:
            g[u].append(v)
        ans = [[] for _ in range(n)]
        for i in range(n):
            bfs(i)
        return ans+
```





### 1151 - 节点与其祖先之间的最大差值<a id="p1151"></a>

#### 问题

给定二叉树的根节点 `root`，找出存在于 **不同** 节点 `A` 和 `B` 之间的最大值 `V`，其中 `V = |A.val - B.val|`，且 `A` 是 `B` 的祖先。

（如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那么我们认为 A 是 B 的祖先）

 

**示例 1：**

![img](./assets/tmp-tree-1712306555061-8.jpg)

```
输入：root = [8,3,10,1,6,null,14,null,null,4,7,13]
输出：7
解释： 
我们有大量的节点与其祖先的差值，其中一些如下：
|8 - 3| = 5
|3 - 7| = 4
|8 - 1| = 7
|10 - 13| = 3
在所有可能的差值中，最大值 7 由 |8 - 1| = 7 得出。
```

**示例 2：**

![img](./assets/tmp-tree-1.jpg)

```
输入：root = [1,null,2,null,0,3]
输出：3
```

 

#### 解法

暴力回溯：

直接传递所有父节点，计算

```python
class Solution:
    def breaktrack(self, root, result, temp):
        if temp:
            result[0] = max(abs(root.val - max(temp)), result[0], abs(root.val - min(temp)))
        # 传递祖先值
        temp.append(root.val)

        if root.left:
            self.breaktrack(root.left, result, temp[:])
        if root.right:
            self.breaktrack(root.right, result, temp)


    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:
        # 寻找最大差值，绝对值
        # 必须是同一棵树
        # 递归寻找
        result = [0]
        self.breaktrack(root, result, [])
        return result[0]
```

正确方法：传递最大值和最小值即可

```python
class Solution(object):
    def maxAncestorDiff(self, root):
        if not root: 
            return 0
        return self.helper(root, root.val, root.val)
    
    def helper(self, node, high, low):
        if not node:
            return high - low
        high = max(high, node.val)
        low = min(low, node.val)
        return max(self.helper(node.left, high, low), self.helper(node.right,high,low))
```



### 1152 - 下降路径最小和 II<a id="p1152"></a>

#### 问题

给你一个 `n x n` 整数矩阵 `grid` ，请你返回 **非零偏移下降路径** 数字和的最小值。

**非零偏移下降路径** 定义为：从 `grid` 数组中的每一行选择一个数字，且按顺序选出来的数字中，相邻数字不在原数组的同一列。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/08/10/falling-grid.jpg)

```
输入：grid = [[1,2,3],[4,5,6],[7,8,9]]
输出：13
解释：
所有非零偏移下降路径包括：
[1,5,9], [1,5,7], [1,6,7], [1,6,8],
[2,4,8], [2,4,9], [2,6,7], [2,6,8],
[3,4,8], [3,4,9], [3,5,7], [3,5,9]
下降路径中数字和最小的是 [1,5,7] ，所以答案是 13 。
```

**示例 2：**

```
输入：grid = [[7]]
输出：7
```

 

#### 解法

回溯：超时6/16

```python
class Solution:
    def breaktrack(self, grid, lastindex, temp, n, result):
        # lastindex代表上层选择的索引，n代表当前的层数
        if n == len(grid):
            result[0] = min(result[0], sum(temp))
            return
        for i in range(len(grid)):
            if i != lastindex:
                self.breaktrack(grid, i, temp + [grid[n][i]], n + 1, result)
    def minFallingPathSum(self, grid: List[List[int]]) -> int:
        # 回溯
        result = [float('inf')]
        deepth = len(grid)
        self.breaktrack(grid, -1, [], 0, result)
        return result[0]
```

动态规划

```python
class Solution:
    def minFallingPathSum(self, grid: List[List[int]]) -> int:
        # 动态规划
        # 索引代表到当前位置的最小叠加值
        dp = [[float('inf')] * len(grid) for _ in range(len(grid))]
        dp[0] = grid[0]
        # 控制层数
        for i in range(1, len(grid)):
            # 控制行数
            for j in range(len(grid)):
                # 控制上层行数
                for k in range(len(grid)):
                    if k != j:
                        dp[i][j] = min(dp[i][j], dp[i - 1][k] + grid[i][j])
        return min(dp[-1])
```



### 1153 - 做菜顺序<a id="p1153"></a>

#### 问题

一个厨师收集了他 `n` 道菜的满意程度 `satisfaction` ，这个厨师做出每道菜的时间都是 1 单位时间。

一道菜的 「 **like-time 系数** 」定义为烹饪这道菜结束的时间（包含之前每道菜所花费的时间）乘以这道菜的满意程度，也就是 `time[i]`*`satisfaction[i]` 。

返回厨师在准备了一定数量的菜肴后可以获得的最大 **like-time 系数** 总和。

你可以按 **任意** 顺序安排做菜的顺序，你也可以选择放弃做某些菜来获得更大的总和。

 

**示例 1：**

```
输入：satisfaction = [-1,-8,0,5,-9]
输出：14
解释：去掉第二道和最后一道菜，最大的 like-time 系数和为 (-1*1 + 0*2 + 5*3 = 14) 。每道菜都需要花费 1 单位时间完成。
```

**示例 2：**

```
输入：satisfaction = [4,3,2]
输出：20
解释：可以按照任意顺序做菜 (2*1 + 3*2 + 4*3 = 20)
```

**示例 3：**

```
输入：satisfaction = [-1,-4,-5]
输出：0
解释：大家都不喜欢这些菜，所以不做任何菜就可以获得最大的 like-time 系数。
```

 

#### 解法

暴力解法

```python
class Solution:
    def maxSatisfaction(self, satisfaction: List[int]) -> int:
        satisfaction.sort()
        res = 0
        # 从后往前做的最大值即可
        # 决定每次做几道菜
        for i in range(1, len(satisfaction) + 1):
            temp = 0
            # 控制做哪个菜
            for j in range(len(satisfaction) - i, len(satisfaction)):
                temp += (j - len(satisfaction) + i + 1) * satisfaction[j]
            res = max(temp, res)
        return res
```

动态规划：根据数学原理推算得出(推算过程：[1402. 做菜顺序 - 灵茶山艾府](https://leetcode.cn/problems/reducing-dishes/solutions/2492854/mei-ju-zuo-ji-dao-cai-tan-xin-pythonjava-k7w2/))

> *f*(*k*)=*f*(*k*−1)+(*a*[0]+*a*[1]+⋯+*a*[*k*−1])

所以可以一面加一面计算。

```python
class Solution:
    def maxSatisfaction(self, satisfaction: List[int]) -> int:
        satisfaction.sort(reverse=True)
        ans, tmp = 0, 0
        for i in satisfaction:
            if tmp + i > 0:
                tmp += i
                ans += tmp
            else:
                break
        return ans
```



### 1154 - 有效的快速序列数目<a id="p1154"></a>

#### 问题

给你 `n` 笔订单，每笔订单都需要快递服务。

计算所有有效的 取货 / 交付 可能的顺序，使 delivery(i) 总是在 pickup(i) 之后。

由于答案可能很大，请返回答案对 10^9 + 7 取余的结果。

 

**示例 1：**

```
输入：n = 1
输出：1
解释：只有一种序列 (P1, D1)，物品 1 的配送服务（D1）在物品 1 的收件服务（P1）后。
```

**示例 2：**

```
输入：n = 2
输出：6
解释：所有可能的序列包括：
(P1,P2,D1,D2)，(P1,P2,D2,D1)，(P1,D1,P2,D2)，(P2,P1,D1,D2)，(P2,P1,D2,D1) 和 (P2,D2,P1,D1)。
(P1,D2,P2,D1) 是一个无效的序列，因为物品 2 的收件服务（P2）不应在物品 2 的配送服务（D2）之后。
```

**示例 3：**

```
输入：n = 3
输出：90
```

 

#### 解法

寻找数学规律即可，实际上就是高中的排列组合。

```python
class Solution:
    def countOrders(self, n: int) -> int:
        # 总的来说就是计算发货取货的方法个数
        dp = [0] * (n + 1)
        dp[0], dp[1] = 0, 1
        lst = [i for i in range(1, n * 2)]
        for i in range(2, n + 1):
            dp[i] = (sum(lst[:i * 2 - 1]) * dp[i - 1]) % (10**9 + 7)
        return dp[-1]
```

优化了运算方法

```python
class Solution:
    def countOrders(self, n: int) -> int:
        res = 1
        MOD = 10**9+7
        for i in range(1,n+1):
            res*= (i*(2*i-1) % MOD)
            res = res % MOD
        return res % MOD
```



### 1155 - 分隔链表<a id="p1155"></a>

#### 问题

给你一个链表的头节点 `head` 和一个特定值 `x` ，请你对链表进行分隔，使得所有 **小于** `x` 的节点都出现在 **大于或等于** `x` 的节点之前。

你应当 **保留** 两个分区中每个节点的初始相对位置。

 

**示例 1：**

![img](./assets/partition.jpg)

```
输入：head = [1,4,3,2,5,2], x = 3
输出：[1,2,2,4,3,5]
```

**示例 2：**

```
输入：head = [2,1], x = 2
输出：[1,2]
```

 

#### 解法

直接在本链表上进行操作

```python
class Solution:
    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:
        res = ListNode(0, head)
        if not head or not head.next:
            return res.next
        l, r = res, head
        # 截断节点，插入
        # per.next = right
        while r:
            per = res
            while per.next != r:
                per = per.next
            if x > r.val:
                # 如果当前节点是头节点就忽略
                if l.next == r:
                    l = l.next
                    r = r.next
                    continue
                ln = l.next
                rn = r.next
                l.next = r
                r.next = ln
                r = rn
                l = l.next
                per.next = rn
            else:
                r = r.next
        return res.next
```

可以直接创建两个链表，一个用于储存小的节点，另一个用于存储其他节点，最后拼接即可。



### 1156 - 无重复字符的最长子串<a id="p1156"></a>

#### 问题

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长**

**子串**

 的长度。



 

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```



#### 解法

拼接子串求长度，可能由于对于字符串的操作较为耗费时间所以速较慢。

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        if not s:
            return 0
        string = [i for i in s]
        # 滑动窗口
        l, r = 0, 1
        s = "" + string[0]
        res = 1
        while r < len(string):
            while string[r] in s:
                res = max(res, len(s))
                l += 1
                s = s[1:]
            s = s + string[r]
            r += 1
        return max(res, len(s))
```

使用集合检验是否重复，配合双指针。

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        if not s:
            return 0
        l, r = 0, 0
        res = 0
        visited = set()
        for i in s:
            if i in visited:
                while s[l] != i:
                    visited.remove(s[l])
                    l+=1
                l+=1
                r+=1
            else:
                visited.add(i)
                r += 1
                res = max(res, r - l)
        return res
```



### 1157 - 寻找两个正序数组的中位数<a id="p1157"></a>

#### 问题

给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。

算法的时间复杂度应该为 `O(log (m+n))` 。

 

**示例 1：**

```
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
```

**示例 2：**

```
输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
```

 

#### 解法

使用索引寻找中位数，对奇偶进行处理即可。

```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        nums = nums1 + nums2
        nums.sort()
        return nums[(len(nums1) + len(nums2)) // 2] if (len(nums1) + len(nums2)) % 2 else (nums[(len(nums1) + len(nums2)) // 2 - 1] + nums[(len(nums1) + len(nums2)) // 2]) / 2
```



### 1158 - 最长回文子串<a id="p1158"></a>

#### 问题

给你一个字符串 `s`，找到 `s` 中最长的回文

子串。

如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。

 

**示例 1：**

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

**示例 2：**

```
输入：s = "cbbd"
输出："bb"
```

 

#### 解法

暴力解法

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        from collections import deque
        # 动态规划
        dp = [0] * (len(s) + 1)
        dp[0] = ""
        # 每次间隔的长度
        for i in range(1, len(s) + 1):
            for j in range(len(s) + 1 - i):
                print(s[j:j + i])
                if s[j:j + i] == s[j:j + i][::-1]:
                    dp[i] = s[j:j + i]
            if dp[i] == 0:
                dp[i] = dp[i - 1]
        return dp[-1]
```

每次根据长度控制索引

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        res = ''
        for i in range(len(s)):
            # 处理起始索引的精髓
            start = max(i - len(res) - 1, 0)
            temp = s[start: i+1]
            if temp == temp[::-1]:
                res = temp
            else:
                temp = temp[1:]
                if temp == temp[::-1]:
                    res = temp
        return res
```



### 1159 - Z字形变换<a id="p1159"></a>

#### 问题

将一个给定字符串 `s` 根据给定的行数 `numRows` ，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 `"PAYPALISHIRING"` 行数为 `3` 时，排列如下：

```
P   A   H   N
A P L S I I G
Y   I   R
```

之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：`"PAHNAPLSIIGYIR"`。

请你实现这个将字符串进行指定行数变换的函数：

```
string convert(string s, int numRows);
```

 

**示例 1：**

```
输入：s = "PAYPALISHIRING", numRows = 3
输出："PAHNAPLSIIGYIR"
```

**示例 2：**

```
输入：s = "PAYPALISHIRING", numRows = 4
输出："PINALSIGYAHRPI"
解释：
P     I    N
A   L S  I G
Y A   H R
P     I
```

**示例 3：**

```
输入：s = "A", numRows = 1
输出："A"
```

 

#### 解法

模拟行为最后拼接。。。

```python
class Solution:
    def convert(self, s: str, numRows: int) -> str:
        if numRows == 1:
            return s
        # 模拟行为
        string = [[0] * len(s) for _ in range(numRows)]
        # x, y控制坐标，i控制字母
        string[0][0] = s[0]
        x, y, i = 0, 1, 1
        while i < len(s):
            # 先赋值再进行操作
            string[y][x] = s[i]
            i += 1
            # 向右上
            if y == numRows - 1:
                x += 1
                y -= 1
                continue
            # 向下
            elif y == 0:
                y += 1
                continue
            if string[y - 1][x] != 0:
                y += 1
            else:
                x += 1
                y -= 1
        res = ''
        for i in range(numRows):
            for j in range(len(s)):
                if string[i][j] != 0:
                    res += string[i][j]
        return res
```

对于模拟行为而言本题只有两个行为：一是向下走，而是向右上走，所以可以很简单的使用中间变量控制反转。

```python
class Solution:
    def convert(self, s: str, numRows: int) -> str:
        if numRows < 2:
            return s
        res = ["" for _ in range(numRows)]
        i, flag = 0, -1
        for c in s:
            res[i] += c
            # 控制反转
            if i == 0 or i == numRows - 1:
                flag = -flag
            i += flag
        return "".join(res)
```



### 1160 - 下一个排列<a id="p1160"></a>

#### 问题

整数数组的一个 **排列** 就是将其所有成员以序列或线性顺序排列。

- 例如，`arr = [1,2,3]` ，以下这些都可以视作 `arr` 的排列：`[1,2,3]`、`[1,3,2]`、`[3,1,2]`、`[2,3,1]` 。

整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 **下一个排列** 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。

- 例如，`arr = [1,2,3]` 的下一个排列是 `[1,3,2]` 。
- 类似地，`arr = [2,3,1]` 的下一个排列是 `[3,1,2]` 。
- 而 `arr = [3,2,1]` 的下一个排列是 `[1,2,3]` ，因为 `[3,2,1]` 不存在一个字典序更大的排列。

给你一个整数数组 `nums` ，找出 `nums` 的下一个排列。

必须**[ 原地 ](https://baike.baidu.com/item/原地算法)**修改，只允许使用额外常数空间。

 

**示例 1：**

```
输入：nums = [1,2,3]
输出：[1,3,2]
```

**示例 2：**

```
输入：nums = [3,2,1]
输出：[1,2,3]
```

**示例 3：**

```
输入：nums = [1,1,5]
输出：[1,5,1]
```

 

#### 解法

数学规律

```python
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        i = len(nums) - 1
        # 倒序寻找第一个降序元素
        while i > 0 and nums[i-1] >= nums[i]:
            i -= 1
        if i != 0:
            j = len(nums) - 1
            # 倒序寻找第一个比目标元素大的元素
            while nums[j] <= nums[i-1]:
                j -= 1
            nums[i-1], nums[j] = nums[j], nums[i-1]
        
        # 排序 i 后面的部分
        nums[i:] = sorted(nums[i:])    
```



### 1161 - 旋转图像<a id="p1161"></a>

#### 问题

给定一个 *n* × *n* 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在**[ 原地](https://baike.baidu.com/item/原地算法)** 旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要** 使用另一个矩阵来旋转图像。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg)

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[7,4,1],[8,5,2],[9,6,3]]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg)

```
输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
```

 

#### 解法

使用额外数组进行逆序

```python
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        temp = []
        for lst in matrix:
            temp.append(lst[:])
        
        lenth = len(matrix)
        for i in range(lenth):
            for j in range(lenth):
                matrix[i][j] = temp[lenth - 1 - j][i]
```

运用数学思想，反转。

```python
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        # 数学
        for i in range(len(matrix)):
            for j in range(i + 1, len(matrix)):
                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
        for nums in matrix:
            nums.reverse()
```



### 1162 - 字符串相乘<a id="p1162"></a>

#### 问题

给定两个以字符串形式表示的非负整数 `num1` 和 `num2`，返回 `num1` 和 `num2` 的乘积，它们的乘积也表示为字符串形式。

**注意：**不能使用任何内置的 BigInteger 库或直接将输入转换为整数。

 

**示例 1:**

```
输入: num1 = "2", num2 = "3"
输出: "6"
```

**示例 2:**

```
输入: num1 = "123", num2 = "456"
输出: "56088"
```

 

#### 解法

运用数学思想即可解

```python
class Solution:
    def multiply(self, num1: str, num2: str) -> str:
        # 将长的值作为第一个乘数，减少遍历次数
        if len(num2) > len(num1):
            num1, num2 = num2, num1
        # 将第一个乘数转换为数字
        num3 = 0
        for num in num1:
            num3 *= 10
            num3 += ord(num) - ord("0")
        res = 0
        for i in range(len(num2)):
            res += num3 * (ord(num2[i]) - ord('0')) * 10 ** (len(num2) - i - 1)
        return str(res)
```



### 1163 -不同的二叉搜索树 II<a id="p1163"></a>

#### 问题

给你一个整数 `n` ，请你生成并返回所有由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的不同 **二叉搜索树** 。可以按 **任意顺序** 返回答案。

 

**示例 1：**

![img](./assets/uniquebstn3.jpg)

```
输入：n = 3
输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]
```

**示例 2：**

```
输入：n = 1
输出：[[1]]
```

 

#### 解法

高级递归

```python
class Solution:
    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:
        return self.generate_tree(1, n) if n else []

    def generate_tree(self, start, end):
        '''
        解题思路：递归分别寻找每层中的每个元素可能的左子树与右子树，然后由当前元素分别与左右子树组成的所有结果，再层层往上返回结果
        :param start: 起始数字
        :param end: 终止数字
        :return: 返回所有符合条件的二叉搜索树
        '''
        if start > end:
            return [None]
        allTrees = []
        for i in range(start, end + 1):  # 枚举可行根节点
            # 获得所有可行的左子树集合
            leftTrees = self.generate_tree(start, i - 1)
            # 获得所有可行的右子树集合
            rightTrees = self.generate_tree(i + 1, end)
            # 从每一层的左子树与右子树集合中各选出一棵，拼接到当前遍历元素的根节点上
            # 其中左子树列表元素的个数，取决于当前层的当前元素可以取的左孩子节点的种类数.如：很明显，当前节点为1时，左孩子只有1种，即为None
            # 同理,其中右子树列表元素的个数，取决于当前层的当前元素可以取的右孩子节点的种类数. 如：很明显，当前节点为1时，右孩子只有2种，即为3->2 or 2->3
            for l in leftTrees:
                for r in rightTrees:
                    currTree = TreeNode(i)
                    currTree.left = l
                    currTree.right = r
                    allTrees.append(currTree)  # 将这一层当前元素所有可能组成的搜索树放到列表中，如果已经是最外层，即表示当前元素所生成的所有的二叉搜索树结果放入list中
        return allTrees
```



### 1164 - 二叉搜索树中的第k小的元素<a id="p1164"></a>

#### 问题

给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 个最小元素（从 1 开始计数）。

 

**示例 1：**

![img](./assets/kthtree1.jpg)

```
输入：root = [3,1,4,null,2], k = 1
输出：1
```

**示例 2：**

![img](./assets/kthtree2.jpg)

```
输入：root = [5,3,6,2,4,null,null,1], k = 3
输出：3
```

 

#### 解法

递归记录树中节点，排序

```python
class Solution:
    def searchall(self, root, res):
        if not root:
            return
        res.append(root.val)
        self.searchall(root.left, res)
        self.searchall(root.right, res)
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        # 使用列表存储树中所有元素
        res = []
        self.searchall(root, res)
        res.sort()
        return res[k - 1]
```

使用中序遍历记录所有节点，按照索引返回

```python
class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        # 二叉搜索树，左侧必定为最小
        from collections import deque
        res, deque = [], collections.deque()
        if root:
            deque.append(root)
        # 前序遍历
        while deque:
            cur = deque.pop()
            if cur:
                if cur.right:
                    deque.append(cur.right)

                deque.append(cur)
                deque.append(None)
                
                if cur.left:
                    deque.append(cur.left)
            else:
                cur = deque.pop()
                res.append(cur.val)
        return res[k - 1]
```

较上优化：遇到索引则直接返回

```python
class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        from collections import deque
        deque, cur = collections.deque(), root
        while True:
            while cur:
                deque.append(cur)
                cur = cur.left
            cur = deque.pop()
            k -= 1
            if k == 0:
                return cur.val
            cur = cur.right
```



### 1165 - 找到冠军 I<a id="p1165"></a>

#### 问题

一场比赛中共有 `n` 支队伍，按从 `0` 到 `n - 1` 编号。

给你一个下标从 **0** 开始、大小为 `n * n` 的二维布尔矩阵 `grid` 。对于满足 `0 <= i, j <= n - 1` 且 `i != j` 的所有 `i, j` ：如果 `grid[i][j] == 1`，那么 `i` 队比 `j` 队 **强** ；否则，`j` 队比 `i` 队 **强** 。

在这场比赛中，如果不存在某支强于 `a` 队的队伍，则认为 `a` 队将会是 **冠军** 。

返回这场比赛中将会成为冠军的队伍。

 

**示例 1：**

```
输入：grid = [[0,1],[0,0]]
输出：0
解释：比赛中有两支队伍。
grid[0][1] == 1 表示 0 队比 1 队强。所以 0 队是冠军。
```

**示例 2：**

```
输入：grid = [[0,0,1],[1,0,1],[0,0,0]]
输出：1
解释：比赛中有三支队伍。
grid[1][0] == 1 表示 1 队比 0 队强。
grid[1][2] == 1 表示 1 队比 2 队强。
所以 1 队是冠军。
```

 

#### 解法

如果是冠军，证明其对所有人都是赢

```python
class Solution:
    def findChampion(self, grid: List[List[int]]) -> int:
        # 图
        for i in range(len(grid)):
            res = 0
            for j in range(len(grid)):
                if i == j:
                    continue
                if grid[i][j] == 0:
                    res += 1
                    break
            if res == 0:
                return i
            res -= 1
```

每次找到更强的就更新

```python
class Solution:
    def findChampion(self, grid: List[List[int]]) -> int:
        n = len(grid)
        ans = 0
        for i in range(n):
            if grid[i][ans] == 1:
                ans = i
        return ans
```



### 1166 - 分割字符串的方案书数<a id="p1166"></a>

#### 问题

给你一个二进制串 `s` （一个只包含 0 和 1 的字符串），我们可以将 `s` 分割成 3 个 **非空** 字符串 s1, s2, s3 （s1 + s2 + s3 = s）。

请你返回分割 `s` 的方案数，满足 s1，s2 和 s3 中字符 '1' 的数目相同。

由于答案可能很大，请将它对 10^9 + 7 取余后返回。

 

**示例 1：**

```
输入：s = "10101"
输出：4
解释：总共有 4 种方法将 s 分割成含有 '1' 数目相同的三个子字符串。
"1|010|1"
"1|01|01"
"10|10|1"
"10|1|01"
```

**示例 2：**

```
输入：s = "1001"
输出：0
```

**示例 3：**

```
输入：s = "0000"
输出：3
解释：总共有 3 种分割 s 的方法。
"0|0|00"
"0|00|0"
"00|0|0"
```

**示例 4：**

```
输入：s = "100100010100110"
输出：12
```

 

#### 解法

转换为数学问题：本质上就是分为三部分，每部分的和是相同的，那么问题在于中间的部分0，这些零的个数就决定了有多少种可能。

```python
class Solution:
    def numWays(self, s: str) -> int:
        sumofs = s.count('1')

        if sumofs % 3:
            return 0
        elif sumofs == 0:
            return ((len(s) - 1) * (len(s) - 2) // 2 % (10 ** 9 + 7))
        
        lst = [i for i, num in enumerate(s) if num == '1']

        sumofs = len(lst)

        return (lst[sumofs // 3] - lst[sumofs // 3 - 1]) * (lst[sumofs // 3 * 2] - lst[sumofs // 3 * 2 - 1]) % (10 ** 9 + 7)
```



占位

ji'xu

继续......

玩爽了......



简单题

jiand

Jian Dan 

简单题 开发

开发，实现接口

继续开发，实现接口

简单题，接口基本开发完毕

简单题

简单题，结束
